[
  {
    "num": "1.1",
    "name": "Палиндром с фильтрацией",
    "code": "def is_palindrome(s: str) -> bool:\n    \"\"\"\n    Проверяет, является ли строка палиндромом.\n    Учитывает только буквы и цифры, игнорирует регистр.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["re", "regex", "import re", "filter", "lambda"],
    "level": "junior",
    "task_text": "Напишите функцию is_palindrome(s: str) -> bool, которая проверяет, является ли строка s палиндромом.\n\nТребования:\n1. Учитывать только буквы английского алфавита (a-z, A-Z) и цифры (0-9)\n2. Игнорировать все остальные символы (пробелы, знаки препинания и т.д.)\n3. Игнорировать регистр символов\n4. Пустая строка считается палиндромом\n\nПримеры:\n\"A man, a plan, a canal: Panama\" → True\n\"race a car\" → False\n\"0P\" → False",
    "hints": {
      "60": "Создайте новую строку, содержащую только символы из s, которые являются буквами или цифрами",
      "120": "Приведите все символы к нижнему регистру и сравните строку с её обратной версией"
    },
    "tests": [
      {"input": "\"A man, a plan, a canal: Panama\"", "output": "True"},
      {"input": "\"race a car\"", "output": "False"},
      {"input": "\"\"", "output": "True"},
      {"input": "\"a\"", "output": "True"},
      {"input": "\"0P\"", "output": "False"},
      {"input": "\"racecar\"", "output": "True"},
      {"input": "\"Able was I ere I saw Elba\"", "output": "True"},
      {"input": "\"12321\"", "output": "True"},
      {"input": "\"123abc321\"", "output": "False"},
      {"input": "\".,\"", "output": "True"},
      {"input": "\"No 'x' in Nixon\"", "output": "True"},
      {"input": "\"Was it a car or a cat I saw?\"", "output": "True"},
      {"input": "\"hello\"", "output": "False"},
      {"input": "\"a b b a\"", "output": "True"},
      {"input": "\"A1b2c3d4c3b2a1\"", "output": "True"}
    ]
  },
  {
    "num": "1.2",
    "name": "Валидные скобки",
    "code": "def is_valid(s: str) -> bool:\n    \"\"\"\n    Проверяет валидность последовательности скобок.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "eval", "exec"],
    "level": "junior",
    "task_text": "Напишите функцию is_valid(s: str) -> bool, которая проверяет, является ли последовательность скобок валидной.\n\nВходная строка содержит только следующие символы: '(', ')', '{', '}', '[', ']'\n\nСтрока является валидной, если:\n1. Открытые скобки закрываются скобками того же типа\n2. Открытые скобки закрываются в правильном порядке\n3. Каждая закрывающая скобка имеет соответствующую открывающую\n\nПримеры:\n\"()\" → True\n\"()[]{}\" → True\n\"(]\" → False\n\"([)]\" → False\n\"{[]}\" → True",
    "hints": {
      "60": "Используйте стек для отслеживания открытых скобок",
      "120": "При встрече закрывающей скобки проверьте, соответствует ли она последней открытой скобке в стеке"
    },
    "tests": [
      {"input": "\"()\"", "output": "True"},
      {"input": "\"()[]{}\"", "output": "True"},
      {"input": "\"(]\"", "output": "False"},
      {"input": "\"([)]\"", "output": "False"},
      {"input": "\"{[]}\"", "output": "True"},
      {"input": "\"\"", "output": "True"},
      {"input": "\"[\"", "output": "False"},
      {"input": "\"]\"", "output": "False"},
      {"input": "\"((()))\"", "output": "True"},
      {"input": "\"[[[]]]\"", "output": "True"},
      {"input": "\"{{{}}}\"", "output": "True"},
      {"input": "\"([{}])\"", "output": "True"},
      {"input": "\"({[]})\"", "output": "False"},
      {"input": "\"(([]){})\"", "output": "True"},
      {"input": "\"([)]\"", "output": "False"}
    ]
  },
  {
    "num": "1.3",
    "name": "Анаграммы",
    "code": "def is_anagram(s: str, t: str) -> bool:\n    \"\"\"\n    Проверяет, являются ли строки анаграммами.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["collections", "Counter", "sorted"],
    "level": "junior",
    "task_text": "Напишите функцию is_anagram(s: str, t: str) -> bool, которая проверяет, являются ли строки анаграммами.\n\nАнаграмма - это слово или фраза, образованная перестановкой букв другого слова или фразы.\n\nПримечания:\n1. Строки могут содержать только строчные английские буквы (a-z)\n2. Можно предположить, что строки непустые\n3. Регистр не имеет значения (все символы уже приведены к нижнему регистру)\n\nПримеры:\n\"anagram\", \"nagaram\" → True\n\"rat\", \"car\" → False\n\"\", \"\" → True",
    "hints": {
      "60": "Подсчитайте количество каждой буквы в обеих строках",
      "120": "Если длины строк разные, они не могут быть анаграммами"
    },
    "tests": [
      {"input": "\"anagram\", \"nagaram\"", "output": "True"},
      {"input": "\"rat\", \"car\"", "output": "False"},
      {"input": "\"\", \"\"", "output": "True"},
      {"input": "\"a\", \"a\"", "output": "True"},
      {"input": "\"a\", \"b\"", "output": "False"},
      {"input": "\"ab\", \"ba\"", "output": "True"},
      {"input": "\"abc\", \"cba\"", "output": "True"},
      {"input": "\"abc\", \"abd\"", "output": "False"},
      {"input": "\"listen\", \"silent\"", "output": "True"},
      {"input": "\"triangle\", \"integral\"", "output": "True"},
      {"input": "\"hello\", \"world\"", "output": "False"},
      {"input": "\"test\", \"tset\"", "output": "True"},
      {"input": "\"aaaa\", \"aaaa\"", "output": "True"},
      {"input": "\"aaaa\", \"aaa\"", "output": "False"},
      {"input": "\"abcde\", \"edcba\"", "output": "True"}
    ]
  },
  {
    "num": "1.4",
    "name": "Самая длинная подстрока без повторений",
    "code": "def length_of_longest_substring(s: str) -> int:\n    \"\"\"\n    Находит длину самой длинной подстроки без повторяющихся символов.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "collections", "defaultdict"],
    "level": "middle",
    "task_text": "Напишите функцию length_of_longest_substring(s: str) -> int, которая находит длину самой длинной подстроки без повторяющихся символов.\n\nПримеры:\n\"abcabcbb\" → 3 (подстрока \"abc\")\n\"bbbbb\" → 1 (подстрока \"b\")\n\"pwwkew\" → 3 (подстрока \"wke\")\n\nПримечания:\n1. Строка может содержать любые символы ASCII\n2. Подстрока должна быть непрерывной\n3. Если строка пустая, вернуть 0",
    "hints": {
      "60": "Используйте технику sliding window (скользящее окно)",
      "120": "Храните последнее вхождение каждого символа и двигайте левую границу окна"
    },
    "tests": [
      {"input": "\"abcabcbb\"", "output": "3"},
      {"input": "\"bbbbb\"", "output": "1"},
      {"input": "\"pwwkew\"", "output": "3"},
      {"input": "\"\"", "output": "0"},
      {"input": "\" \"", "output": "1"},
      {"input": "\"au\"", "output": "2"},
      {"input": "\"dvdf\"", "output": "3"},
      {"input": "\"abcd\"", "output": "4"},
      {"input": "\"aaaaa\"", "output": "1"},
      {"input": "\"abcdeabc\"", "output": "5"},
      {"input": "\"abba\"", "output": "2"},
      {"input": "\"tmmzuxt\"", "output": "5"},
      {"input": "\"abcdefghijklmnopqrstuvwxyz\"", "output": "26"},
      {"input": "\"aaabcdef\"", "output": "6"},
      {"input": "\"abcabcabcd\"", "output": "4"}
    ]
  },
  {
    "num": "1.5",
    "name": "Сжатие строки (RLE)",
    "code": "def compress_string(s: str) -> str:\n    \"\"\"\n    Сжимает строку по алгоритму RLE.\n    Если сжатая строка не короче, возвращает исходную.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "itertools", "groupby"],
    "level": "junior",
    "task_text": "Напишите функцию compress_string(s: str) -> str, которая реализует алгоритм сжатия строки Run-Length Encoding (RLE).\n\nФормат сжатия: символ + количество повторений подряд\nПример: \"aaabbc\" → \"a3b2c1\"\n\nТребования:\n1. Если сжатая строка не короче исходной, вернуть исходную строку\n2. Строка может содержать любые символы ASCII\n3. Если строка пустая, вернуть пустую строку\n\nПримеры:\n\"aaabbccccd\" → \"a3b2c4d1\"\n\"abc\" → \"abc\" (так как \"a1b1c1\" длиннее)\n\"a\" → \"a\"",
    "hints": {
      "60": "Проходите по строке и считайте последовательные одинаковые символы",
      "120": "Собирайте результат в список, а затем объединяйте в строку для эффективности"
    },
    "tests": [
      {"input": "\"aaabbccccd\"", "output": "\"a3b2c4d1\""},
      {"input": "\"abc\"", "output": "\"abc\""},
      {"input": "\"a\"", "output": "\"a\""},
      {"input": "\"aaaa\"", "output": "\"a4\""},
      {"input": "\"\"", "output": "\"\""},
      {"input": "\"abbcccddddeeeee\"", "output": "\"a1b2c3d4e5\""},
      {"input": "\"aabbcc\"", "output": "\"a2b2c2\""},
      {"input": "\"abcd\"", "output": "\"abcd\""},
      {"input": "\"aaaaaaaaaa\"", "output": "\"a10\""},
      {"input": "\"aaaabbbb\"", "output": "\"a4b4\""},
      {"input": "\"ab\"", "output": "\"ab\""},
      {"input": "\"aaab\"", "output": "\"a3b1\""},
      {"input": "\"aabbaa\"", "output": "\"a2b2a2\""},
      {"input": "\"112233\"", "output": "\"112233\""},
      {"input": "\"111222\"", "output": "\"1323\""}
    ]
  },
  {
    "num": "2.1",
    "name": "Сумма двух чисел",
    "code": "def two_sum(nums: list, target: int) -> list:\n    \"\"\"\n    Находит индексы двух чисел, дающих в сумме target.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "enumerate", "itertools"],
    "level": "junior",
    "task_text": "Напишите функцию two_sum(nums: list, target: int) -> list, которая возвращает индексы двух чисел из списка nums, которые в сумме дают target.\n\nПредположения:\n1. Каждый вход имеет ровно одно решение\n2. Нельзя использовать один и тот же элемент дважды\n3. Можно вернуть ответ в любом порядке\n4. Индексы начинаются с 0\n\nПримеры:\nnums = [2,7,11,15], target = 9 → [0,1]\nnums = [3,2,4], target = 6 → [1,2]\nnums = [3,3], target = 6 → [0,1]",
    "hints": {
      "60": "Используйте словарь для хранения чисел и их индексов",
      "120": "Для каждого числа проверяйте, есть ли в словаре complement (target - num)"
    },
    "tests": [
      {"input": "[2,7,11,15], 9", "output": "[0,1]"},
      {"input": "[3,2,4], 6", "output": "[1,2]"},
      {"input": "[3,3], 6", "output": "[0,1]"},
      {"input": "[0,4,3,0], 0", "output": "[0,3]"},
      {"input": "[-1,-2,-3,-4,-5], -8", "output": "[2,4]"},
      {"input": "[1,2,3,4,5], 9", "output": "[3,4]"},
      {"input": "[1,5,7,9], 12", "output": "[1,2]"},
      {"input": "[10,20,30], 40", "output": "[0,2]"},
      {"input": "[100,200,300,400], 500", "output": "[1,3]"},
      {"input": "[1], 2", "output": "[]"},
      {"input": "[], 0", "output": "[]"},
      {"input": "[5,5], 10", "output": "[0,1]"},
      {"input": "[1,2,3], 5", "output": "[1,2]"},
      {"input": "[4,5,6], 10", "output": "[0,2]"},
      {"input": "[7,8,9], 15", "output": "[0,1]"}
    ]
  },
  {
    "num": "2.2",
    "name": "Лучшее время для покупки и продажи акций",
    "code": "def max_profit(prices: list) -> int:\n    \"\"\"\n    Находит максимальную прибыль от одной сделки покупки/продажи.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "max", "min"],
    "level": "junior",
    "task_text": "Напишите функцию max_profit(prices: list) -> int, которая находит максимальную возможную прибыль от одной сделки покупки и продажи акций.\n\nДаны цены акций на каждый день (prices[i] - цена в i-й день).\nВы можете совершить только одну транзакцию (купить один раз и продать один раз).\nЕсли прибыль невозможна, верните 0.\n\nПримеры:\n[7,1,5,3,6,4] → 5 (купить по 1, продать по 6)\n[7,6,4,3,1] → 0 (невозможно получить прибыль)\n[1] → 0\n[] → 0",
    "hints": {
      "60": "Отслеживайте минимальную цену, увиденную на данный момент",
      "120": "Для каждой цены вычисляйте потенциальную прибыль и обновляйте максимум"
    },
    "tests": [
      {"input": "[7,1,5,3,6,4]", "output": "5"},
      {"input": "[7,6,4,3,1]", "output": "0"},
      {"input": "[1]", "output": "0"},
      {"input": "[]", "output": "0"},
      {"input": "[1,2]", "output": "1"},
      {"input": "[2,1]", "output": "0"},
      {"input": "[3,2,1]", "output": "0"},
      {"input": "[1,2,3,4,5]", "output": "4"},
      {"input": "[5,4,3,2,1]", "output": "0"},
      {"input": "[2,4,1]", "output": "2"},
      {"input": "[2,1,2,0,1]", "output": "1"},
      {"input": "[3,3,5,0,0,3,1,4]", "output": "4"},
      {"input": "[1,3,2,8,4,9]", "output": "8"},
      {"input": "[2,1,4]", "output": "3"},
      {"input": "[6,1,3,2,4,7]", "output": "6"}
    ]
  },
  {
    "num": "2.3",
    "name": "Содержит дубликаты",
    "code": "def contains_duplicate(nums: list) -> bool:\n    \"\"\"\n    Проверяет, содержит ли массив дубликаты.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "collections", "Counter", "set"],
    "level": "junior",
    "task_text": "Напишите функцию contains_duplicate(nums: list) -> bool, которая проверяет, содержит ли массив дубликаты.\n\nВозвращает True, если любое значение появляется в массиве хотя бы два раза.\nВозвращает False, если все элементы различны.\n\nПримеры:\n[1,2,3,1] → True\n[1,2,3,4] → False\n[1,1,1,3,3,4,3,2,4,2] → True\n[] → False\n[1] → False",
    "hints": {
      "60": "Используйте структуру данных для отслеживания уже увиденных элементов",
      "120": "Если найдете элемент, который уже есть в структуре, верните True"
    },
    "tests": [
      {"input": "[1,2,3,1]", "output": "True"},
      {"input": "[1,2,3,4]", "output": "False"},
      {"input": "[1,1,1,3,3,4,3,2,4,2]", "output": "True"},
      {"input": "[]", "output": "False"},
      {"input": "[1]", "output": "False"},
      {"input": "[0,0,0]", "output": "True"},
      {"input": "[-1,0,1]", "output": "False"},
      {"input": "[-1,0,1,-1]", "output": "True"},
      {"input": "[100,200,300,100]", "output": "True"},
      {"input": "[1,2,3,4,5,6,7,8,9,10]", "output": "False"},
      {"input": "[1,2,3,4,5,6,7,8,9,1]", "output": "True"},
      {"input": "[10,20,30,40,50,10]", "output": "True"},
      {"input": "[7,8,9,7,8,9]", "output": "True"},
      {"input": "[0]", "output": "False"},
      {"input": "[1,2,3,2,1]", "output": "True"}
    ]
  },
  {
    "num": "2.4",
    "name": "Произведение массива кроме себя",
    "code": "def product_except_self(nums: list) -> list:\n    \"\"\"\n    Возвращает массив, где каждый элемент равен произведению всех элементов кроме nums[i].\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "division", "/", "eval", "exec"],
    "level": "middle",
    "task_text": "Напишите функцию product_except_self(nums: list) -> list, которая возвращает массив answer такой, что answer[i] равен произведению всех элементов nums кроме nums[i].\n\nТребования:\n1. Нельзя использовать операцию деления\n2. Должна работать за O(n) времени\n3. Дополнительная память O(1), не считая массива результата\n4. Исходный массив может содержать отрицательные числа и нули\n\nПримеры:\n[1,2,3,4] → [24,12,8,6]\n[-1,1,0,-3,3] → [0,0,9,0,0]\n[0,0] → [0,0]\n[1,1] → [1,1]",
    "hints": {
      "60": "Используйте два прохода: слева направо и справа налево",
      "120": "Храните произведение элементов слева и справа от текущего индекса"
    },
    "tests": [
      {"input": "[1,2,3,4]", "output": "[24,12,8,6]"},
      {"input": "[-1,1,0,-3,3]", "output": "[0,0,9,0,0]"},
      {"input": "[0,0]", "output": "[0,0]"},
      {"input": "[1,1]", "output": "[1,1]"},
      {"input": "[1]", "output": "[1]"},
      {"input": "[2,3]", "output": "[3,2]"},
      {"input": "[1,2,3]", "output": "[6,3,2]"},
      {"input": "[4,5,6]", "output": "[30,24,20]"},
      {"input": "[0,1,2,3]", "output": "[6,0,0,0]"},
      {"input": "[1,0,2,0,3]", "output": "[0,0,0,0,0]"},
      {"input": "[-1,-2,-3]", "output": "[6,3,2]"},
      {"input": "[1,-1,1,-1]", "output": "[-1,1,-1,1]"},
      {"input": "[10,20,30]", "output": "[600,300,200]"},
      {"input": "[0,10,20]", "output": "[200,0,0]"},
      {"input": "[1,2,4,8]", "output": "[64,32,16,8]"}
    ]
  },
  {
    "num": "2.5",
    "name": "Максимальная сумма подмассива",
    "code": "def max_subarray(nums: list) -> int:\n    \"\"\"\n    Находит максимальную сумму непрерывного подмассива.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "itertools", "combinations"],
    "level": "middle",
    "task_text": "Напишите функцию max_subarray(nums: list) -> int, которая находит максимальную сумму непрерывного подмассива.\n\nЭто классическая задача, известная как \"Maximum Subarray Problem\" (алгоритм Кадане).\n\nПримеры:\n[-2,1,-3,4,-1,2,1,-5,4] → 6 (подмассив [4,-1,2,1])\n[1] → 1\n[5,4,-1,7,8] → 23 (весь массив)\n[-1] → -1\n[-2,-1] → -1",
    "hints": {
      "60": "Используйте динамическое программирование: для каждого элемента решайте, начать новый подмассив или продолжить текущий",
      "120": "Храните текущую сумму и максимальную сумму. Если текущая сумма становится отрицательной, сбрасывайте её"
    },
    "tests": [
      {"input": "[-2,1,-3,4,-1,2,1,-5,4]", "output": "6"},
      {"input": "[1]", "output": "1"},
      {"input": "[5,4,-1,7,8]", "output": "23"},
      {"input": "[-1]", "output": "-1"},
      {"input": "[-2,-1]", "output": "-1"},
      {"input": "[]", "output": "0"},
      {"input": "[1,2,3]", "output": "6"},
      {"input": "[-1,-2,-3]", "output": "-1"},
      {"input": "[0,0,0,0]", "output": "0"},
      {"input": "[1,-2,3,-1,2,-4,5]", "output": "7"},
      {"input": "[10,-20,30]", "output": "30"},
      {"input": "[-5,-4,-3,-2]", "output": "-2"},
      {"input": "[2,-1,2,3,4,-5]", "output": "10"},
      {"input": "[1,2,-1,3,4]", "output": "9"},
      {"input": "[100,-1,100]", "output": "199"}
    ]
  },
  {
    "num": "2.6",
    "name": "Максимальное произведение подмассива",
    "code": "def max_product(nums: list) -> int:\n    \"\"\"\n    Находит максимальное произведение непрерывного подмассива.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "math", "prod", "numpy"],
    "level": "middle",
    "task_text": "Напишите функцию max_product(nums: list) -> int, которая находит максимальное произведение непрерывного подмассива.\n\nМассив может содержать как положительные, так и отрицательные числа.\nОбратите внимание: произведение двух отрицательных чисел дает положительное число.\n\nПримеры:\n[2,3,-2,4] → 6 (подмассив [2,3])\n[-2,0,-1] → 0\n[0,2] → 2\n[-2,3,-4] → 24\n[1] → 1",
    "hints": {
      "60": "Отслеживайте как максимальное, так и минимальное произведение (минимальное может стать максимальным при умножении на отрицательное)",
      "120": "Для каждого элемента обновляйте максимум и минимум произведения"
    },
    "tests": [
      {"input": "[2,3,-2,4]", "output": "6"},
      {"input": "[-2,0,-1]", "output": "0"},
      {"input": "[0,2]", "output": "2"},
      {"input": "[-2,3,-4]", "output": "24"},
      {"input": "[1]", "output": "1"},
      {"input": "[-1]", "output": "-1"},
      {"input": "[-2,-3,-4]", "output": "12"},
      {"input": "[1,0,3,5]", "output": "15"},
      {"input": "[1,-2,3,-4,5]", "output": "120"},
      {"input": "[0,0,0]", "output": "0"},
      {"input": "[2,-5,-2,-4,3]", "output": "24"},
      {"input": "[3,-1,4]", "output": "4"},
      {"input": "[-3,0,1,-2]", "output": "1"},
      {"input": "[1,2,0,3,4]", "output": "12"},
      {"input": "[10,-10,10,-10]", "output": "10000"}
    ]
  },
  {
    "num": "2.7",
    "name": "Поиск в отсортированном повернутом массиве",
    "code": "def search_rotated(nums: list, target: int) -> int:\n    \"\"\"\n    Ищет target в отсортированном, но повернутом массиве.\n    Возвращает индекс или -1.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "index", "find", "bisect"],
    "level": "middle",
    "task_text": "Напишите функцию search_rotated(nums: list, target: int) -> int, которая ищет target в массиве, который был отсортирован по возрастанию, а затем повернут в неизвестной точке.\n\nВозвращает индекс target или -1, если его нет.\n\nПримеры:\nnums = [4,5,6,7,0,1,2], target = 0 → 4\nnums = [4,5,6,7,0,1,2], target = 3 → -1\nnums = [1], target = 0 → -1\nnums = [1,3], target = 3 → 1\nnums = [3,1], target = 1 → 1",
    "hints": {
      "60": "Используйте модифицированный бинарный поиск. Определите, в какой половине находится target",
      "120": "Сравните средний элемент с левым, чтобы определить, какая половина отсортирована"
    },
    "tests": [
      {"input": "[4,5,6,7,0,1,2], 0", "output": "4"},
      {"input": "[4,5,6,7,0,1,2], 3", "output": "-1"},
      {"input": "[1], 0", "output": "-1"},
      {"input": "[1,3], 3", "output": "1"},
      {"input": "[3,1], 1", "output": "1"},
      {"input": "[], 1", "output": "-1"},
      {"input": "[1,2,3,4,5], 3", "output": "2"},
      {"input": "[5,1,2,3,4], 5", "output": "0"},
      {"input": "[2,3,4,5,1], 1", "output": "4"},
      {"input": "[6,7,8,1,2,3,4,5], 8", "output": "2"},
      {"input": "[6,7,8,1,2,3,4,5], 1", "output": "3"},
      {"input": "[3,4,5,6,7,8,1,2], 8", "output": "5"},
      {"input": "[10,11,12,13,1,2,3], 13", "output": "3"},
      {"input": "[100,200,300,400,0,50], 300", "output": "2"},
      {"input": "[7,8,9,1,2,3,4,5,6], 9", "output": "2"}
    ]
  },
  {
    "num": "2.8",
    "name": "Три числа, дающие сумму 0",
    "code": "def three_sum(nums: list) -> list:\n    \"\"\"\n    Находит все уникальные тройки, сумма которых равна 0.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "itertools", "combinations", "collections"],
    "level": "middle",
    "task_text": "Напишите функцию three_sum(nums: list) -> list, которая находит все уникальные тройки в массиве, которые в сумме дают 0.\n\nТребования:\n1. Не должно быть дублирующихся троек\n2. Возвращайте список списков с тройками\n3. Порядок элементов в тройке не имеет значения\n4. Массив может содержать дубликаты\n\nПримеры:\n[-1,0,1,2,-1,-4] → [[-1,-1,2],[-1,0,1]]\n[] → []\n[0] → []\n[0,0,0] → [[0,0,0]]\n[1,2,-2,-1] → [[-2,0,2],[-1,0,1]]",
    "hints": {
      "60": "Отсортируйте массив. Для каждого элемента используйте технику two pointers для поиска оставшихся двух",
      "120": "Пропускайте дубликаты, чтобы избежать повторяющихся троек"
    },
    "tests": [
      {"input": "[-1,0,1,2,-1,-4]", "output": "[[-1,-1,2],[-1,0,1]]"},
      {"input": "[]", "output": "[]"},
      {"input": "[0]", "output": "[]"},
      {"input": "[0,0,0]", "output": "[[0,0,0]]"},
      {"input": "[1,2,-2,-1]", "output": "[[-2,0,2],[-1,0,1]]"},
      {"input": "[0,0,0,0]", "output": "[[0,0,0]]"},
      {"input": "[-1,0,1,0]", "output": "[[-1,0,1]]"},
      {"input": "[-2,0,1,1,2]", "output": "[[-2,0,2],[-2,1,1]]"},
      {"input": "[-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]", "output": "[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,-2,4],[-2,0,2]]"},
      {"input": "[1,2,3]", "output": "[]"},
      {"input": "[-1,-2,-3]", "output": "[]"},
      {"input": "[3,0,-2,-1,1,2]", "output": "[[-2,-1,3],[-2,0,2],[-1,0,1]]"},
      {"input": "[-5,0,5]", "output": "[[-5,0,5]]"},
      {"input": "[10,-10,0,5,-5]", "output": "[[-10,0,10],[-5,0,5]]"},
      {"input": "[1,1,-2]", "output": "[[-2,1,1]]"}
    ]
  },
  {
    "num": "2.9",
    "name": "Контейнер с наибольшим количеством воды",
    "code": "def max_area(height: list) -> int:\n    \"\"\"\n    Находит максимальную площадь контейнера, который может содержать воду.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "itertools", "combinations", "max"],
    "level": "middle",
    "task_text": "Напишите функцию max_area(height: list) -> int, которая находит максимальную площадь контейнера с водой.\n\nДаны n вертикальных линий, где i-я линия находится в точке i и имеет высоту height[i].\nНайдите две линии, которые вместе с осью X образуют контейнер, содержащий наибольшее количество воды.\n\nПлощадь = минимальная_высота * расстояние_между_линиями\n\nПримеры:\n[1,8,6,2,5,4,8,3,7] → 49\n[1,1] → 1\n[4,3,2,1,4] → 16\n[1,2,1] → 2",
    "hints": {
      "60": "Используйте технику two pointers, начиная с краев массива",
      "120": "Двигайте указатель с меньшей высотой, так как ограничивающим фактором является минимальная высота"
    },
    "tests": [
      {"input": "[1,8,6,2,5,4,8,3,7]", "output": "49"},
      {"input": "[1,1]", "output": "1"},
      {"input": "[4,3,2,1,4]", "output": "16"},
      {"input": "[1,2,1]", "output": "2"},
      {"input": "[1]", "output": "0"},
      {"input": "[]", "output": "0"},
      {"input": "[1,2,3,4,5]", "output": "6"},
      {"input": "[5,4,3,2,1]", "output": "6"},
      {"input": "[2,3,4,5,18,17,6]", "output": "17"},
      {"input": "[10,1,1,10]", "output": "30"},
      {"input": "[1,8,100,2,100,4,8,3,7]", "output": "200"},
      {"input": "[1,2,4,3]", "output": "4"},
      {"input": "[3,9,3,4,7,2,12,6]", "output": "45"},
      {"input": "[6,4,3,1,2,5]", "output": "20"},
      {"input": "[100,1,100,1,100]", "output": "400"}
    ]
  },
  {
    "num": "2.10",
    "name": "Слияние интервалов",
    "code": "def merge_intervals(intervals: list) -> list:\n    \"\"\"\n    Объединяет все перекрывающиеся интервалы.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "sorted", "sort"],
    "level": "middle",
    "task_text": "Напишите функцию merge_intervals(intervals: list) -> list, которая объединяет все перекрывающиеся интервалы.\n\nКаждый интервал представлен как [start, end].\nИнтервалы перекрываются, если end текущего >= start следующего.\n\nПримеры:\n[[1,3],[2,6],[8,10],[15,18]] → [[1,6],[8,10],[15,18]]\n[[1,4],[4,5]] → [[1,5]]\n[[1,4],[0,4]] → [[0,4]]\n[[1,4],[2,3]] → [[1,4]]\n[] → []",
    "hints": {
      "60": "Отсортируйте интервалы по start. Затем объединяйте последовательные интервалы, если они перекрываются",
      "120": "Для каждого интервала проверяйте, перекрывается ли он с последним в результате"
    },
    "tests": [
      {"input": "[[1,3],[2,6],[8,10],[15,18]]", "output": "[[1,6],[8,10],[15,18]]"},
      {"input": "[[1,4],[4,5]]", "output": "[[1,5]]"},
      {"input": "[[1,4],[0,4]]", "output": "[[0,4]]"},
      {"input": "[[1,4],[2,3]]", "output": "[[1,4]]"},
      {"input": "[]", "output": "[]"},
      {"input": "[[1,1]]", "output": "[[1,1]]"},
      {"input": "[[1,4],[0,0]]", "output": "[[0,0],[1,4]]"},
      {"input": "[[1,2],[3,4],[5,6]]", "output": "[[1,2],[3,4],[5,6]]"},
      {"input": "[[1,10],[2,3],[4,5],[6,7],[8,9]]", "output": "[[1,10]]"},
      {"input": "[[2,3],[4,5],[6,7],[8,9],[1,10]]", "output": "[[1,10]]"},
      {"input": "[[1,3],[2,4],[5,7],[6,8]]", "output": "[[1,4],[5,8]]"},
      {"input": "[[1,2],[2,3],[3,4],[4,5]]", "output": "[[1,5]]"},
      {"input": "[[0,30],[5,10],[15,20]]", "output": "[[0,30]]"},
      {"input": "[[1,2],[3,4],[0,5]]", "output": "[[0,5]]"},
      {"input": "[[2,3],[1,4],[0,5]]", "output": "[[0,5]]"}
    ]
  },
  {
    "num": "3.1",
    "name": "Подъем по лестнице",
    "code": "def climb_stairs(n: int) -> int:\n    \"\"\"\n    Возвращает количество способов подняться на n ступенек.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "math", "factorial", "comb"],
    "level": "junior",
    "task_text": "Напишите функцию climb_stairs(n: int) -> int, которая возвращает количество способов подняться на лестницу из n ступенек.\n\nЗа один шаг можно подняться на 1 или 2 ступеньки.\n\nПримеры:\nn = 2 → 2 (1+1, 2)\nn = 3 → 3 (1+1+1, 1+2, 2+1)\nn = 1 → 1\nn = 0 → 1\nn = 4 → 5 (1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2)",
    "hints": {
      "60": "Это задача на числа Фибоначчи: ways(n) = ways(n-1) + ways(n-2)",
      "120": "Используйте динамическое программирование или мемоизацию"
    },
    "tests": [
      {"input": "2", "output": "2"},
      {"input": "3", "output": "3"},
      {"input": "1", "output": "1"},
      {"input": "0", "output": "1"},
      {"input": "4", "output": "5"},
      {"input": "5", "output": "8"},
      {"input": "6", "output": "13"},
      {"input": "7", "output": "21"},
      {"input": "8", "output": "34"},
      {"input": "9", "output": "55"},
      {"input": "10", "output": "89"},
      {"input": "20", "output": "10946"},
      {"input": "30", "output": "1346269"},
      {"input": "35", "output": "14930352"},
      {"input": "45", "output": "1836311903"}
    ]
  },
  {
    "num": "3.2",
    "name": "Размен монет",
    "code": "def coin_change(coins: list, amount: int) -> int:\n    \"\"\"\n    Возвращает минимальное количество монет для размена суммы.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "itertools", "combinations"],
    "level": "middle",
    "task_text": "Напишите функцию coin_change(coins: list, amount: int) -> int, которая возвращает минимальное количество монет, необходимых для составления суммы amount.\n\nЕсли сумму нельзя составить, верните -1.\nМожно использовать неограниченное количество монет каждого номинала.\n\nПримеры:\ncoins = [1,2,5], amount = 11 → 3 (5+5+1)\ncoins = [2], amount = 3 → -1\ncoins = [1], amount = 0 → 0\ncoins = [1,2,5], amount = 100 → 20\ncoins = [2,5,10], amount = 13 → 4 (10+2+1? нет 1!) → -1",
    "hints": {
      "60": "Используйте динамическое программирование: dp[i] = минимальное количество монет для суммы i",
      "120": "Инициализируйте dp[0] = 0, остальные как бесконечность. Для каждой монеты обновляйте dp"
    },
    "tests": [
      {"input": "[1,2,5], 11", "output": "3"},
      {"input": "[2], 3", "output": "-1"},
      {"input": "[1], 0", "output": "0"},
      {"input": "[1,2,5], 100", "output": "20"},
      {"input": "[2,5,10], 13", "output": "-1"},
      {"input": "[1], 1", "output": "1"},
      {"input": "[1], 10", "output": "10"},
      {"input": "[2,3,5], 8", "output": "2"},
      {"input": "[2,3,5], 7", "output": "2"},
      {"input": "[3,7], 9", "output": "3"},
      {"input": "[1,3,4], 6", "output": "2"},
      {"input": "[1,5,10,25], 30", "output": "2"},
      {"input": "[1,5,10,25], 41", "output": "4"},
      {"input": "[2,4], 7", "output": "-1"},
      {"input": "[186,419,83,408], 6249", "output": "20"}
    ]
  },
  {
    "num": "3.3",
    "name": "Наибольшая возрастающая подпоследовательность",
    "code": "def length_of_lis(nums: list) -> int:\n    \"\"\"\n    Возвращает длину наибольшей возрастающей подпоследовательности.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "bisect", "collections"],
    "level": "middle",
    "task_text": "Напишите функцию length_of_lis(nums: list) -> int, которая возвращает длину наибольшей строго возрастающей подпоследовательности.\n\nПодпоследовательность — это последовательность, которую можно получить из массива удалением некоторых элементов без изменения порядка оставшихся элементов.\n\nПримеры:\n[10,9,2,5,3,7,101,18] → 4 ([2,5,7,101])\n[0,1,0,3,2,3] → 4 ([0,1,2,3])\n[7,7,7,7,7] → 1 ([7])\n[] → 0\n[1] → 1",
    "hints": {
      "60": "Используйте динамическое программирование: dp[i] = длина LIS, заканчивающейся на nums[i]",
      "120": "Более эффективный подход: поддерживайте массив tails, где tails[i] = минимальный последний элемент LIS длины i+1"
    },
    "tests": [
      {"input": "[10,9,2,5,3,7,101,18]", "output": "4"},
      {"input": "[0,1,0,3,2,3]", "output": "4"},
      {"input": "[7,7,7,7,7]", "output": "1"},
      {"input": "[]", "output": "0"},
      {"input": "[1]", "output": "1"},
      {"input": "[3,2,1]", "output": "1"},
      {"input": "[1,2,3]", "output": "3"},
      {"input": "[1,3,2,4,5,6]", "output": "5"},
      {"input": "[4,10,4,3,8,9]", "output": "3"},
      {"input": "[1,2,4,3,5,4,7,2]", "output": "5"},
      {"input": "[10,22,9,33,21,50,41,60,80]", "output": "6"},
      {"input": "[2,5,3,7,11,8,10,13,6]", "output": "6"},
      {"input": "[0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]", "output": "6"},
      {"input": "[100,99,98,97,96]", "output": "1"},
      {"input": "[1,2,3,1,2,3,4,5]", "output": "5"}
    ]
  },
  {
    "num": "3.4",
    "name": "Разбиение слова",
    "code": "def word_break(s: str, word_dict: list) -> bool:\n    \"\"\"\n    Проверяет, можно ли разбить строку на слова из словаря.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "re", "regex"],
    "level": "middle",
    "task_text": "Напишите функцию word_break(s: str, word_dict: list) -> bool, которая проверяет, можно ли разбить строку s на последовательность слов из словаря.\n\nКаждое слово из словаря можно использовать несколько раз.\n\nПримеры:\ns = \"leetcode\", word_dict = [\"leet\",\"code\"] → True\ns = \"applepenapple\", word_dict = [\"apple\",\"pen\"] → True\ns = \"catsandog\", word_dict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] → False\ns = \"\", word_dict = [\"a\",\"b\"] → True\ns = \"a\", word_dict = [] → False",
    "hints": {
      "60": "Используйте динамическое программирование: dp[i] = можно ли разбить префикс длины i",
      "120": "dp[0] = True. Для каждой позиции i проверяйте все j < i: если dp[j] и s[j:i] в словаре, то dp[i] = True"
    },
    "tests": [
      {"input": "\"leetcode\", [\"leet\",\"code\"]", "output": "True"},
      {"input": "\"applepenapple\", [\"apple\",\"pen\"]", "output": "True"},
      {"input": "\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]", "output": "False"},
      {"input": "\"\", [\"a\",\"b\"]", "output": "True"},
      {"input": "\"a\", []", "output": "False"},
      {"input": "\"aaaaaaa\", [\"aaaa\",\"aaa\"]", "output": "True"},
      {"input": "\"abcd\", [\"a\",\"abc\",\"b\",\"cd\"]", "output": "True"},
      {"input": "\"abcd\", [\"ab\",\"cd\"]", "output": "True"},
      {"input": "\"abcd\", [\"abc\",\"d\"]", "output": "True"},
      {"input": "\"abcd\", [\"a\",\"b\",\"c\"]", "output": "False"},
      {"input": "\"cars\", [\"car\",\"ca\",\"rs\"]", "output": "True"},
      {"input": "\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]", "output": "True"},
      {"input": "\"catsand\", [\"cat\",\"cats\",\"and\",\"sand\"]", "output": "True"},
      {"input": "\"aaaaaaaa\", [\"aaaa\",\"aa\",\"a\"]", "output": "True"},
      {"input": "\"aaaaaaaaab\", [\"a\",\"aa\",\"aaa\",\"aaaa\"]", "output": "False"}
    ]
  },
  {
    "num": "3.5",
    "name": "Грабитель домов",
    "code": "def rob(nums: list) -> int:\n    \"\"\"\n    Возвращает максимальную сумму, которую можно украсть, не грабя соседние дома.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "itertools", "combinations"],
    "level": "middle",
    "task_text": "Напишите функцию rob(nums: list) -> int, которая возвращает максимальную сумму, которую можно украсть, не грабя два соседних дома.\n\nКаждый дом содержит определенную сумму денег. Грабитель не может грабить два соседних дома, так как сработает сигнализация.\n\nПримеры:\n[1,2,3,1] → 4 (дом 1 + дом 3)\n[2,7,9,3,1] → 12 (дом 1 + дом 3 + дом 5)\n[2,1,1,2] → 4 (дом 1 + дом 4)\n[1] → 1\n[] → 0",
    "hints": {
      "60": "Используйте динамическое программирование: dp[i] = максимальная сумма для первых i домов",
      "120": "dp[i] = max(dp[i-1], dp[i-2] + nums[i]). Можно обойтись двумя переменными"
    },
    "tests": [
      {"input": "[1,2,3,1]", "output": "4"},
      {"input": "[2,7,9,3,1]", "output": "12"},
      {"input": "[2,1,1,2]", "output": "4"},
      {"input": "[1]", "output": "1"},
      {"input": "[]", "output": "0"},
      {"input": "[0]", "output": "0"},
      {"input": "[100]", "output": "100"},
      {"input": "[1,2]", "output": "2"},
      {"input": "[2,1]", "output": "2"},
      {"input": "[3,2,1,5]", "output": "8"},
      {"input": "[6,7,1,3,8,2,4]", "output": "19"},
      {"input": "[5,3,4,11,2]", "output": "16"},
      {"input": "[1,3,1,3,100]", "output": "103"},
      {"input": "[2,3,2]", "output": "4"},
      {"input": "[1,1,1,1,1,1]", "output": "3"}
    ]
  },
  {
    "num": "3.6",
    "name": "Уникальные пути",
    "code": "def unique_paths(m: int, n: int) -> int:\n    \"\"\"\n    Возвращает количество уникальных путей из левого верхнего угла в правый нижний.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "math", "comb", "factorial"],
    "level": "middle",
    "task_text": "Напишите функцию unique_paths(m: int, n: int) -> int, которая возвращает количество уникальных путей из левого верхнего угла сетки m x n в правый нижний угол.\n\nРобот может двигаться только вниз или вправо.\n\nПримеры:\nm=3, n=7 → 28\nm=3, n=2 → 3\nm=1, n=1 → 1\nm=0, n=0 → 0\nm=7, n=3 → 28",
    "hints": {
      "60": "Используйте динамическое программирование: dp[i][j] = количество путей до клетки (i,j)",
      "120": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Можно использовать одномерный массив для оптимизации"
    },
    "tests": [
      {"input": "3, 7", "output": "28"},
      {"input": "3, 2", "output": "3"},
      {"input": "1, 1", "output": "1"},
      {"input": "0, 0", "output": "0"},
      {"input": "7, 3", "output": "28"},
      {"input": "1, 10", "output": "1"},
      {"input": "10, 1", "output": "1"},
      {"input": "2, 2", "output": "2"},
      {"input": "2, 3", "output": "3"},
      {"input": "3, 3", "output": "6"},
      {"input": "4, 4", "output": "20"},
      {"input": "5, 5", "output": "70"},
      {"input": "6, 6", "output": "252"},
      {"input": "10, 10", "output": "48620"},
      {"input": "23, 12", "output": "193536720"}
    ]
  },
  {
    "num": "3.7",
    "name": "Расстояние редактирования",
    "code": "def min_distance(word1: str, word2: str) -> int:\n    \"\"\"\n    Возвращает минимальное количество операций для преобразования word1 в word2.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "Levenshtein", "distance"],
    "level": "hard",
    "task_text": "Напишите функцию min_distance(word1: str, word2: str) -> int, которая возвращает минимальное количество операций для преобразования word1 в word2.\n\nДопустимые операции:\n1. Вставка символа\n2. Удаление символа\n3. Замена символа\n\nПримеры:\n\"horse\", \"ros\" → 3 (horse → rorse → rose → ros)\n\"intention\", \"execution\" → 5\n\"\", \"\" → 0\n\"a\", \"b\" → 1\n\"\", \"abc\" → 3",
    "hints": {
      "60": "Используйте динамическое программирование: dp[i][j] = минимальное расстояние между word1[:i] и word2[:j]",
      "120": "dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + (0 if word1[i-1]==word2[j-1] else 1))"
    },
    "tests": [
      {"input": "\"horse\", \"ros\"", "output": "3"},
      {"input": "\"intention\", \"execution\"", "output": "5"},
      {"input": "\"\", \"\"", "output": "0"},
      {"input": "\"a\", \"b\"", "output": "1"},
      {"input": "\"\", \"abc\"", "output": "3"},
      {"input": "\"abc\", \"\"", "output": "3"},
      {"input": "\"kitten\", \"sitting\"", "output": "3"},
      {"input": "\"saturday\", \"sunday\"", "output": "3"},
      {"input": "\"abcd\", \"abcd\"", "output": "0"},
      {"input": "\"abcd\", \"abce\"", "output": "1"},
      {"input": "\"abcd\", \"abc\"", "output": "1"},
      {"input": "\"abc\", \"abcd\"", "output": "1"},
      {"input": "\"abc\", \"def\"", "output": "3"},
      {"input": "\"food\", \"money\"", "output": "4"},
      {"input": "\"algorithm\", \"altruistic\"", "output": "6"}
    ]
  },
  {
    "num": "4.1",
    "name": "Количество островов",
    "code": "def num_islands(grid: list) -> int:\n    \"\"\"\n    Возвращает количество островов в сетке.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "numpy", "scipy"],
    "level": "middle",
    "task_text": "Напишите функцию num_islands(grid: list) -> int, которая возвращает количество островов в сетке.\n\nСетка представлена как список списков, где '1' - земля, '0' - вода.\nОстров образован соединенными по горизонтали или вертикали участками земли.\n\nПример:\ngrid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n] → 1\n\ngrid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n] → 3",
    "hints": {
      "60": "Используйте поиск в глубину (DFS) или поиск в ширину (BFS) для обхода каждого острова",
      "120": "При обнаружении '1' увеличьте счетчик и обнулите все связанные клетки этого острова"
    },
    "tests": [
      {"input": "[[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]", "output": "1"},
      {"input": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]", "output": "3"},
      {"input": "[[\"0\",\"0\",\"0\",\"0\",\"0\"]]", "output": "0"},
      {"input": "[[\"1\",\"0\",\"1\",\"0\",\"1\"]]", "output": "3"},
      {"input": "[[\"1\"]]", "output": "1"},
      {"input": "[[\"0\"]]", "output": "0"},
      {"input": "[[\"1\",\"1\",\"1\"],[\"0\",\"1\",\"0\"],[\"1\",\"1\",\"1\"]]", "output": "1"},
      {"input": "[[\"1\",\"0\",\"1\"],[\"0\",\"1\",\"0\"],[\"1\",\"0\",\"1\"]]", "output": "5"},
      {"input": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]", "output": "2"},
      {"input": "[[\"1\",\"0\",\"1\",\"0\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"0\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\"]]", "output": "10"}
    ]
  },
  {
    "num": "4.2",
    "name": "Курсы по расписанию",
    "code": "def can_finish(num_courses: int, prerequisites: list) -> bool:\n    \"\"\"\n    Проверяет, можно ли закончить все курсы с учетом предварительных условий.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "networkx", "graph"],
    "level": "middle",
    "task_text": "Напишите функцию can_finish(num_courses: int, prerequisites: list) -> bool, которая проверяет, можно ли закончить все курсы с учетом предварительных условий.\n\nprerequisites - список пар [a, b], означающих что для курса a нужно сначала пройти курс b.\n\nПримеры:\nnum_courses=2, prerequisites=[[1,0]] → True (сначала курс 0, потом 1)\nnum_courses=2, prerequisites=[[1,0],[0,1]] → False (циклическая зависимость)\nnum_courses=3, prerequisites=[[1,0],[2,1]] → True\nnum_courses=1, prerequisites=[] → True",
    "hints": {
      "60": "Это задача на обнаружение циклов в ориентированном графе. Используйте топологическую сортировку",
      "120": "Используйте алгоритм Кана (Kahn's algorithm) или DFS с отслеживанием посещенных узлов"
    },
    "tests": [
      {"input": "2, [[1,0]]", "output": "True"},
      {"input": "2, [[1,0],[0,1]]", "output": "False"},
      {"input": "3, [[1,0],[2,1]]", "output": "True"},
      {"input": "1, []", "output": "True"},
      {"input": "4, [[1,0],[2,1],[3,2]]", "output": "True"},
      {"input": "4, [[1,0],[2,1],[3,2],[0,3]]", "output": "False"},
      {"input": "5, [[1,0],[2,0],[3,1],[4,2],[4,3]]", "output": "True"},
      {"input": "3, [[0,1],[1,2],[2,0]]", "output": "False"},
      {"input": "6, [[1,0],[2,1],[3,2],[4,3],[5,4]]", "output": "True"},
      {"input": "6, [[1,0],[2,1],[3,2],[4,3],[5,4],[0,5]]", "output": "False"},
      {"input": "0, []", "output": "True"},
      {"input": "10, []", "output": "True"},
      {"input": "4, [[0,1],[1,2],[2,3],[3,0]]", "output": "False"},
      {"input": "5, [[0,1],[1,2],[2,3],[3,4]]", "output": "True"},
      {"input": "7, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,0]]", "output": "False"}
    ]
  },
  {
    "num": "4.3",
    "name": "Максимальная площадь острова",
    "code": "def max_area_of_island(grid: list) -> int:\n    \"\"\"\n    Возвращает максимальную площадь острова в сетке.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "numpy", "scipy"],
    "level": "middle",
    "task_text": "Напишите функцию max_area_of_island(grid: list) -> int, которая возвращает максимальную площадь острова в сетке.\n\nСетка представлена как список списков, где 1 - земля, 0 - вода.\nПлощадь острова - количество соединенных по горизонтали или вертикали клеток земли.\n\nПример:\ngrid = [\n  [0,0,1,0,0,0,0,1,0,0,0,0,0],\n  [0,0,0,0,0,0,0,1,1,1,0,0,0],\n  [0,1,1,0,1,0,0,0,0,0,0,0,0],\n  [0,1,0,0,1,1,0,0,1,0,1,0,0],\n  [0,1,0,0,1,1,0,0,1,1,1,0,0],\n  [0,0,0,0,0,0,0,0,0,0,1,0,0],\n  [0,0,0,0,0,0,0,1,1,1,0,0,0],\n  [0,0,0,0,0,0,0,1,1,0,0,0,0]\n] → 6",
    "hints": {
      "60": "Используйте DFS или BFS для обхода каждого острова и подсчета его площади",
      "120": "Храните максимальную найденную площадь и обновляйте её при каждом новом острове"
    },
    "tests": [
      {"input": "[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]", "output": "6"},
      {"input": "[[0,0,0,0,0,0,0,0]]", "output": "0"},
      {"input": "[[1,1,1,1,1]]", "output": "5"},
      {"input": "[[1,0,1],[0,1,0],[1,0,1]]", "output": "1"},
      {"input": "[[1,1,1],[1,0,1],[1,1,1]]", "output": "8"},
      {"input": "[[1]]", "output": "1"},
      {"input": "[[0]]", "output": "0"},
      {"input": "[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]", "output": "4"},
      {"input": "[[1,0,1,1,0,1,0,0],[0,1,1,0,0,0,1,1],[1,0,1,0,1,0,0,0],[0,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,0]]", "output": "8"},
      {"input": "[[1,1,0,1,1],[1,0,0,0,0],[0,0,0,0,1],[1,1,0,1,1]]", "output": "4"}
    ]
  },
  {
    "num": "4.4",
    "name": "Лестница слов",
    "code": "def ladder_length(begin_word: str, end_word: str, word_list: list) -> int:\n    \"\"\"\n    Возвращает длину кратчайшей последовательности преобразования слов.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "collections", "deque", "defaultdict"],
    "level": "hard",
    "task_text": "Напишите функцию ladder_length(begin_word: str, end_word: str, word_list: list) -> int, которая возвращает длину кратчайшей последовательности преобразования из begin_word в end_word.\n\nПравила:\n1. За один шаг можно изменить только одну букву\n2. Каждое промежуточное слово должно быть в word_list\n3. Если преобразование невозможно, вернуть 0\n\nПример:\nbegin_word = \"hit\", end_word = \"cog\", word_list = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] → 5\n(hit → hot → dot → dog → cog)",
    "hints": {
      "60": "Используйте BFS для поиска кратчайшего пути в графе слов",
      "120": "Постройте граф, где слова соединены если отличаются на одну букву. Используйте двунаправленный BFS для оптимизации"
    },
    "tests": [
      {"input": "\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]", "output": "5"},
      {"input": "\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]", "output": "0"},
      {"input": "\"hot\", \"dog\", [\"hot\",\"dog\"]", "output": "0"},
      {"input": "\"hot\", \"dot\", [\"hot\",\"dot\",\"dog\"]", "output": "2"},
      {"input": "\"a\", \"c\", [\"a\",\"b\",\"c\"]", "output": "2"},
      {"input": "\"lost\", \"cost\", [\"most\",\"fist\",\"lost\",\"cost\",\"fish\"]", "output": "2"},
      {"input": "\"red\", \"tax\", [\"ted\",\"tex\",\"red\",\"tax\",\"tad\",\"den\",\"rex\",\"pee\"]", "output": "4"},
      {"input": "\"game\", \"thee\", [\"frye\",\"heat\",\"tree\",\"thee\",\"game\",\"fare\",\"hear\",\"gave\",\"gold\"]", "output": "7"},
      {"input": "\"talk\", \"tail\", [\"talk\",\"tons\",\"fall\",\"tail\",\"gale\",\"hall\",\"negs\"]", "output": "0"},
      {"input": "\"same\", \"cost\", [\"same\",\"came\",\"case\",\"cast\",\"cost\"]", "output": "4"}
    ]
  },
  {
    "num": "5.1",
    "name": "Минимум в отсортированном повернутом массиве",
    "code": "def find_min(nums: list) -> int:\n    \"\"\"\n    Находит минимальный элемент в отсортированном повернутом массиве.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "min", "sorted"],
    "level": "middle",
    "task_text": "Напишите функцию find_min(nums: list) -> int, которая находит минимальный элемент в отсортированном по возрастанию массиве, который был повернут в неизвестной точке.\n\nМассив не содержит дубликатов.\n\nПримеры:\n[3,4,5,1,2] → 1\n[4,5,6,7,0,1,2] → 0\n[11,13,15,17] → 11\n[1] → 1\n[] → -1 (или выбросить исключение)",
    "hints": {
      "60": "Используйте модифицированный бинарный поиск",
      "120": "Сравните средний элемент с правым: если nums[mid] > nums[right], минимум справа, иначе слева"
    },
    "tests": [
      {"input": "[3,4,5,1,2]", "output": "1"},
      {"input": "[4,5,6,7,0,1,2]", "output": "0"},
      {"input": "[11,13,15,17]", "output": "11"},
      {"input": "[1]", "output": "1"},
      {"input": "[]", "output": "-1"},
      {"input": "[2,1]", "output": "1"},
      {"input": "[5,6,7,8,9,1,2,3,4]", "output": "1"},
      {"input": "[10,20,30,40,50]", "output": "10"},
      {"input": "[100,200,300,400,10,20]", "output": "10"},
      {"input": "[7,8,1,2,3,4,5,6]", "output": "1"},
      {"input": "[3,1,2]", "output": "1"},
      {"input": "[2,3,4,5,6,1]", "output": "1"},
      {"input": "[9,10,11,12,13,14,15,16,1,2,3,4,5,6,7,8]", "output": "1"},
      {"input": "[6,7,8,9,10,1,2,3,4,5]", "output": "1"},
      {"input": "[0,1,2,3,4,5]", "output": "0"}
    ]
  },
  {
    "num": "5.2",
    "name": "Поиск пика в массиве",
    "code": "def find_peak_element(nums: list) -> int:\n    \"\"\"\n    Находит индекс пикового элемента в массиве.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "max", "argmax"],
    "level": "middle",
    "task_text": "Напишите функцию find_peak_element(nums: list) -> int, которая находит индекс пикового элемента в массиве.\n\nПиковый элемент - элемент, который больше своих соседей.\nДля краевых элементов достаточно быть больше одного соседа.\nМожно предположить, что nums[i] ≠ nums[i+1] для всех i.\n\nПримеры:\n[1,2,3,1] → 2 (элемент 3)\n[1,2,1,3,5,6,4] → 1 или 5 (элемент 2 или 6)\n[1] → 0\n[1,2] → 1\n[2,1] → 0",
    "hints": {
      "60": "Используйте бинарный поиск. Сравните средний элемент с его правым соседом",
      "120": "Если nums[mid] < nums[mid+1], пик находится справа, иначе слева"
    },
    "tests": [
      {"input": "[1,2,3,1]", "output": "2"},
      {"input": "[1,2,1,3,5,6,4]", "output": "5"},
      {"input": "[1]", "output": "0"},
      {"input": "[1,2]", "output": "1"},
      {"input": "[2,1]", "output": "0"},
      {"input": "[1,2,3,4,5]", "output": "4"},
      {"input": "[5,4,3,2,1]", "output": "0"},
      {"input": "[1,3,2,1]", "output": "1"},
      {"input": "[1,2,3,4,3,2,1]", "output": "3"},
      {"input": "[10,20,15,2,23,90,67]", "output": "5"},
      {"input": "[1,2,3,4,5,4,3,2,1]", "output": "4"},
      {"input": "[100,80,60,40,20]", "output": "0"},
      {"input": "[10,20,30,40,50]", "output": "4"},
      {"input": "[5,10,20,15]", "output": "2"},
      {"input": "[1,3,20,4,1,0]", "output": "2"}
    ]
  },
  {
    "num": "5.3",
    "name": "Поиск в матрице",
    "code": "def search_matrix(matrix: list, target: int) -> bool:\n    \"\"\"\n    Ищет target в отсортированной по строкам и столбцам матрице.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "numpy", "flatten"],
    "level": "middle",
    "task_text": "Напишите функцию search_matrix(matrix: list, target: int) -> bool, которая ищет target в матрице.\n\nМатрица отсортирована по строкам и столбцам:\n- Каждая строка отсортирована по возрастанию слева направо\n- Каждый столбец отсортирован по возрастанию сверху вниз\n\nПример:\nmatrix = [\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\ntarget = 5 → True\ntarget = 20 → False",
    "hints": {
      "60": "Начните поиск из правого верхнего или левого нижнего угла",
      "120": "Из правого верхнего: если target меньше текущего, двигайтесь влево; если больше - вниз"
    },
    "tests": [
      {"input": "[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], 5", "output": "True"},
      {"input": "[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], 20", "output": "False"},
      {"input": "[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], 1", "output": "True"},
      {"input": "[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], 30", "output": "True"},
      {"input": "[[1]], 1", "output": "True"},
      {"input": "[[1]], 2", "output": "False"},
      {"input": "[[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3", "output": "True"},
      {"input": "[[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13", "output": "False"},
      {"input": "[[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]], 15", "output": "True"},
      {"input": "[[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]], 26", "output": "False"},
      {"input": "[[-5]], -5", "output": "True"},
      {"input": "[[-1,3]], 3", "output": "True"},
      {"input": "[[1,4],[2,5]], 2", "output": "True"},
      {"input": "[[1,1]], 0", "output": "False"},
      {"input": "[[1,1]], 2", "output": "False"}
    ]
  },
  {
    "num": "6.1",
    "name": "Проверка степени двойки",
    "code": "def is_power_of_two(n: int) -> bool:\n    \"\"\"\n    Проверяет, является ли число степенью двойки.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "math", "log"],
    "level": "junior",
    "task_text": "Напишите функцию is_power_of_two(n: int) -> bool, которая проверяет, является ли число степенью двойки.\n\nПримеры:\n1 → True (2⁰)\n16 → True (2⁴)\n3 → False\n0 → False\n-8 → False\n1024 → True",
    "hints": {
      "60": "Степень двойки в двоичном представлении имеет ровно одну единицу",
      "120": "Используйте побитовые операции: n & (n-1) == 0 для n > 0"
    },
    "tests": [
      {"input": "1", "output": "True"},
      {"input": "16", "output": "True"},
      {"input": "3", "output": "False"},
      {"input": "0", "output": "False"},
      {"input": "-8", "output": "False"},
      {"input": "1024", "output": "True"},
      {"input": "1023", "output": "False"},
      {"input": "256", "output": "True"},
      {"input": "512", "output": "True"},
      {"input": "100", "output": "False"},
      {"input": "128", "output": "True"},
      {"input": "255", "output": "False"},
      {"input": "1073741824", "output": "True"},
      {"input": "2147483647", "output": "False"},
      {"input": "2147483648", "output": "True"}
    ]
  },
  {
    "num": "6.2",
    "name": "Количество единиц в двоичном представлении",
    "code": "def hamming_weight(n: int) -> int:\n    \"\"\"\n    Возвращает количество единиц в двоичном представлении числа.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "bin", "count"],
    "level": "junior",
    "task_text": "Напишите функцию hamming_weight(n: int) -> int, которая возвращает количество единиц в двоичном представлении числа (вес Хэмминга).\n\nЧисло представлено как целое со знаком (32 бита).\n\nПримеры:\n11 (1011) → 3\n128 (10000000) → 1\n4294967293 (11111111111111111111111111111101) → 31\n0 → 0\n1 → 1",
    "hints": {
      "60": "Используйте побитовые операции. Можно сдвигать число вправо и проверять младший бит",
      "120": "Оптимальное решение: n &= n-1 удаляет младшую единицу. Повторяйте пока n ≠ 0"
    },
    "tests": [
      {"input": "11", "output": "3"},
      {"input": "128", "output": "1"},
      {"input": "4294967293", "output": "31"},
      {"input": "0", "output": "0"},
      {"input": "1", "output": "1"},
      {"input": "2", "output": "1"},
      {"input": "3", "output": "2"},
      {"input": "255", "output": "8"},
      {"input": "256", "output": "1"},
      {"input": "511", "output": "9"},
      {"input": "1023", "output": "10"},
      {"input": "2047", "output": "11"},
      {"input": "4095", "output": "12"},
      {"input": "8191", "output": "13"},
      {"input": "2147483647", "output": "31"}
    ]
  },
  {
    "num": "6.3",
    "name": "Обратные биты",
    "code": "def reverse_bits(n: int) -> int:\n    \"\"\"\n    Обращает биты 32-битного беззнакового целого числа.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "int", "format"],
    "level": "middle",
    "task_text": "Напишите функцию reverse_bits(n: int) -> int, которая обращает биты 32-битного беззнакового целого числа.\n\nПример:\n00000010100101000001111010011100 → 00111001011110000010100101000000\nДесятично: 43261596 → 964176192\n\nПримечание: входное число представлено как 32-битное беззнаковое целое",
    "hints": {
      "60": "Извлекайте биты по одному с конца и добавляйте в результат",
      "120": "Сдвигайте результат влево, извлекайте младший бит n и добавляйте его"
    },
    "tests": [
      {"input": "43261596", "output": "964176192"},
      {"input": "4294967293", "output": "3221225471"},
      {"input": "0", "output": "0"},
      {"input": "1", "output": "2147483648"},
      {"input": "2", "output": "1073741824"},
      {"input": "3", "output": "3221225472"},
      {"input": "255", "output": "4278190080"},
      {"input": "256", "output": "16777216"},
      {"input": "65535", "output": "4294901760"},
      {"input": "2147483647", "output": "4294967294"},
      {"input": "2147483648", "output": "1"},
      {"input": "1431655765", "output": "1431655765"},
      {"input": "2863311530", "output": "2863311530"},
      {"input": "16777215", "output": "4278190080"},
      {"input": "16777216", "output": "256"}
    ]
  },
  {
    "num": "7.1",
    "name": "Проверка счастливого числа",
    "code": "def is_happy(n: int) -> bool:\n    \"\"\"\n    Проверяет, является ли число счастливым.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "math", "set"],
    "level": "junior",
    "task_text": "Напишите функцию is_happy(n: int) -> bool, которая проверяет, является ли число счастливым.\n\nСчастливое число определяется следующим процессом:\n1. Начиная с любого положительного целого числа, заменяйте число суммой квадратов его цифр\n2. Повторяйте процесс до тех пор, пока число не станет равным 1 (счастливое) или не войдет в бесконечный цикл\n\nПримеры:\n19 → True (1² + 9² = 82 → 8² + 2² = 68 → 6² + 8² = 100 → 1² + 0² + 0² = 1)\n2 → False\n1 → True\n7 → True",
    "hints": {
      "60": "Используйте множество для обнаружения циклов",
      "120": "Быстрый и медленный указатель (Floyd's cycle detection) может определить цикл без дополнительной памяти"
    },
    "tests": [
      {"input": "19", "output": "True"},
      {"input": "2", "output": "False"},
      {"input": "1", "output": "True"},
      {"input": "7", "output": "True"},
      {"input": "10", "output": "True"},
      {"input": "13", "output": "True"},
      {"input": "4", "output": "False"},
      {"input": "44", "output": "True"},
      {"input": "86", "output": "True"},
      {"input": "68", "output": "True"},
      {"input": "100", "output": "True"},
      {"input": "28", "output": "True"},
      {"input": "31", "output": "True"},
      {"input": "32", "output": "True"},
      {"input": "37", "output": "False"}
    ]
  },
  {
    "num": "7.2",
    "name": "Проверка степени трех",
    "code": "def is_power_of_three(n: int) -> bool:\n    \"\"\"\n    Проверяет, является ли число степенью тройки.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "math", "log"],
    "level": "junior",
    "task_text": "Напишите функцию is_power_of_three(n: int) -> bool, которая проверяет, является ли число степенью тройки.\n\nПримеры:\n27 → True (3³)\n0 → False\n9 → True\n45 → False\n1 → True (3⁰)\n-27 → False",
    "hints": {
      "60": "Можно делить число на 3 пока оно делится нацело",
      "120": "Проверьте, что n > 0 и наибольшая степень тройки (3¹⁹) делится на n"
    },
    "tests": [
      {"input": "27", "output": "True"},
      {"input": "0", "output": "False"},
      {"input": "9", "output": "True"},
      {"input": "45", "output": "False"},
      {"input": "1", "output": "True"},
      {"input": "-27", "output": "False"},
      {"input": "81", "output": "True"},
      {"input": "243", "output": "True"},
      {"input": "729", "output": "True"},
      {"input": "2187", "output": "True"},
      {"input": "6561", "output": "True"},
      {"input": "19683", "output": "True"},
      {"input": "59049", "output": "True"},
      {"input": "177147", "output": "True"},
      {"input": "531441", "output": "True"}
    ]
  },
  {
    "num": "7.3",
    "name": "Подсчет простых чисел",
    "code": "def count_primes(n: int) -> int:\n    \"\"\"\n    Возвращает количество простых чисел меньше n.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "math", "sympy"],
    "level": "middle",
    "task_text": "Напишите функцию count_primes(n: int) -> int, которая возвращает количество простых чисел, меньших n.\n\nПримеры:\n10 → 4 (2, 3, 5, 7)\n0 → 0\n1 → 0\n2 → 0\n100 → 25\n10000 → 1229",
    "hints": {
      "60": "Используйте решето Эратосфена для эффективного нахождения всех простых чисел",
      "120": "Оптимизируйте, проверяя только до √n и пропуская четные числа"
    },
    "tests": [
      {"input": "10", "output": "4"},
      {"input": "0", "output": "0"},
      {"input": "1", "output": "0"},
      {"input": "2", "output": "0"},
      {"input": "100", "output": "25"},
      {"input": "10000", "output": "1229"},
      {"input": "20", "output": "8"},
      {"input": "30", "output": "10"},
      {"input": "50", "output": "15"},
      {"input": "500", "output": "95"},
      {"input": "1000", "output": "168"},
      {"input": "5000", "output": "669"},
      {"input": "100000", "output": "9592"},
      {"input": "1000000", "output": "78498"},
      {"input": "10000000", "output": "664579"}
    ]
  },
  {
    "num": "8.1",
    "name": "Проверка валидного судоку",
    "code": "def is_valid_sudoku(board: list) -> bool:\n    \"\"\"\n    Проверяет, является ли заполнение судоку валидным.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "numpy", "defaultdict"],
    "level": "middle",
    "task_text": "Напишите функцию is_valid_sudoku(board: list) -> bool, которая проверяет, является ли заполнение доски судоку валидным.\n\nДоска 9x9 представлена как список из 9 списков. Пустые клетки обозначены '.'\n\nПравила:\n1. Каждая строка должна содержать цифры 1-9 без повторений\n2. Каждый столбец должен содержать цифры 1-9 без повторений\n3. Каждый подквадрат 3x3 должен содержать цифры 1-9 без повторений\n\nПример валидной доски:\n[\n  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n] → True",
    "hints": {
      "60": "Используйте множества для отслеживания цифр в строках, столбцах и подквадратах",
      "120": "Индекс подквадрата можно вычислить как (row//3)*3 + col//3"
    },
    "tests": [
      {"input": "[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]", "output": "True"},
      {"input": "[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]", "output": "False"},
      {"input": "[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]*9", "output": "True"},
      {"input": "[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],[\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"1\"],[\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\",\"3\"],[\"5\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\",\"3\",\"4\"],[\"6\",\"7\",\"8\",\"9\",\"1\",\"2\",\"3\",\"4\",\"5\"],[\"7\",\"8\",\"9\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"],[\"8\",\"9\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\"],[\"9\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\"]]", "output": "False"},
      {"input": "[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]", "output": "True"}
    ]
  },
  {
    "num": "8.2",
    "name": "Вращение изображения",
    "code": "def rotate_image(matrix: list) -> None:\n    \"\"\"\n    Вращает изображение (матрицу) на 90 градусов по часовой стрелке in-place.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "numpy", "rot90"],
    "level": "middle",
    "task_text": "Напишите функцию rotate_image(matrix: list) -> None, которая вращает изображение (матрицу N×N) на 90 градусов по часовой стрелке на месте.\n\nПример:\n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n] → [\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n\nТребуется модифицировать матрицу на месте, не используя дополнительную матрицу.",
    "hints": {
      "60": "Сначала транспонируйте матрицу, затем отразите каждую строку",
      "120": "Или меняйте элементы по кругу: для каждого слоя меняйте 4 элемента за раз"
    },
    "tests": [
      {"input": "[[1,2,3],[4,5,6],[7,8,9]]", "output": "[[7,4,1],[8,5,2],[9,6,3]]"},
      {"input": "[[1,2],[3,4]]", "output": "[[3,1],[4,2]]"},
      {"input": "[[1]]", "output": "[[1]]"},
      {"input": "[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]", "output": "[[13,9,5,1],[14,10,6,2],[15,11,7,3],[16,12,8,4]]"},
      {"input": "[[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]", "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"}
    ]
  },
  {
    "num": "8.3",
    "name": "Спиральный обход матрицы",
    "code": "def spiral_order(matrix: list) -> list:\n    \"\"\"\n    Возвращает элементы матрицы в порядке спирального обхода.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "numpy", "itertools"],
    "level": "middle",
    "task_text": "Напишите функцию spiral_order(matrix: list) -> list, которая возвращает элементы матрицы в порядке спирального обхода (по часовой стрелке).\n\nПример:\n[\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n] → [1,2,3,6,9,8,7,4,5]\n\n[\n  [1,2,3,4],\n  [5,6,7,8],\n  [9,10,11,12]\n] → [1,2,3,4,8,12,11,10,9,5,6,7]",
    "hints": {
      "60": "Определите границы: top, bottom, left, right. Обходите по кругу",
      "120": "1. Слева направо по верхней границе\n2. Сверху вниз по правой границе\n3. Справа налево по нижней границе\n4. Снизу вверх по левой границе"
    },
    "tests": [
      {"input": "[[1,2,3],[4,5,6],[7,8,9]]", "output": "[1,2,3,6,9,8,7,4,5]"},
      {"input": "[[1,2,3,4],[5,6,7,8],[9,10,11,12]]", "output": "[1,2,3,4,8,12,11,10,9,5,6,7]"},
      {"input": "[[1]]", "output": "[1]"},
      {"input": "[[1,2],[3,4]]", "output": "[1,2,4,3]"},
      {"input": "[[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]]", "output": "[1,2,3,4,5,10,15,20,25,24,23,22,21,16,11,6,7,8,9,14,19,18,17,12,13]"},
      {"input": "[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]", "output": "[1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]"},
      {"input": "[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]", "output": "[1,2,3,6,9,12,11,10,7,4,5,8]"},
      {"input": "[[1,2],[3,4],[5,6],[7,8]]", "output": "[1,2,4,6,8,7,5,3]"},
      {"input": "[[1,2,3,4,5,6],[7,8,9,10,11,12],[13,14,15,16,17,18]]", "output": "[1,2,3,4,5,6,12,18,17,16,15,14,13,7,8,9,10,11]"},
      {"input": "[]", "output": "[]"}
    ]
  }
]