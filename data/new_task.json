[
  {
    "num": "1.1",
    "name": "Палиндромная сумма",
    "code": "def palindrome_sum(n: int) -> int:\n    \"\"\"\n    Возвращает сумму всех чисел-палиндромов от 1 до n включительно.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import"],
    "level": "junior",
    "task_text": "Напишите функцию palindrome_sum(n: int) -> int, которая возвращает сумму всех чисел-палиндромов от 1 до n включительно.\n\nЧисло-палиндром читается одинаково слева направо и справа налево.\n\nПримеры:\n10 → 45 (палиндромы: 1,2,3,4,5,6,7,8,9)\n20 → 99 (добавляется 11)\n100 → 540 (добавляются 22,33,44,55,66,77,88,99)\n0 → 0",
    "hints": {
      "60": "Проверьте, равна ли строка числа своей обратной версии",
      "120": "Можно обойтись без преобразования в строку, переворачивая число математически"
    },
    "test_code": [
      "def test_palindrome_sum_10(): assert palindrome_sum(10) == 45",
      "def test_palindrome_sum_20(): assert palindrome_sum(20) == 99",
      "def test_palindrome_sum_100(): assert palindrome_sum(100) == 540",
      "def test_palindrome_sum_0(): assert palindrome_sum(0) == 0",
      "def test_palindrome_sum_1(): assert palindrome_sum(1) == 1",
      "def test_palindrome_sum_11(): assert palindrome_sum(11) == 66",
      "def test_palindrome_sum_50(): assert palindrome_sum(50) == 246",
      "def test_palindrome_sum_99(): assert palindrome_sum(99) == 540",
      "def test_palindrome_sum_200(): assert palindrome_sum(200) == 1181",
      "def test_palindrome_sum_1000(): assert palindrome_sum(1000) == 50040"
    ]
  },
  {
    "num": "1.2",
    "name": "Минимальные шаги к 1",
    "code": "def min_steps_to_one(n: int) -> int:\n    \"\"\"\n    Возвращает минимальное количество шагов для приведения числа n к 1.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию min_steps_to_one(n: int) -> int, которая возвращает минимальное количество шагов для приведения числа n к 1, используя следующие операции:\n1. Вычесть 1\n2. Разделить на 2 (если делится нацело)\n3. Разделить на 3 (если делится нацело)\n\nПримеры:\n1 → 0 (уже 1)\n2 → 1 (2 → 1)\n3 → 1 (3 → 1)\n4 → 2 (4 → 2 → 1 или 4 → 3 → 1)\n10 → 3 (10 → 9 → 3 → 1)\n15 → 4 (15 → 5 → 4 → 2 → 1)",
    "hints": {
      "60": "Используйте динамическое программирование",
      "120": "Начните с 1 и двигайтесь к n, запоминая минимальные шаги для каждого числа"
    },
    "test_code": [
      "def test_min_steps_1(): assert min_steps_to_one(1) == 0",
      "def test_min_steps_2(): assert min_steps_to_one(2) == 1",
      "def test_min_steps_3(): assert min_steps_to_one(3) == 1",
      "def test_min_steps_4(): assert min_steps_to_one(4) == 2",
      "def test_min_steps_10(): assert min_steps_to_one(10) == 3",
      "def test_min_steps_15(): assert min_steps_to_one(15) == 4",
      "def test_min_steps_20(): assert min_steps_to_one(20) == 4",
      "def test_min_steps_27(): assert min_steps_to_one(27) == 3",
      "def test_min_steps_30(): assert min_steps_to_one(30) == 4",
      "def test_min_steps_100(): assert min_steps_to_one(100) == 7"
    ]
  },
  {
    "num": "1.3",
    "name": "Сумма цифр факториала",
    "code": "def factorial_digit_sum(n: int) -> int:\n    \"\"\"\n    Возвращает сумму цифр факториала числа n.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import", "math"],
    "level": "middle",
    "task_text": "Напишите функцию factorial_digit_sum(n: int) -> int, которая возвращает сумму цифр факториала числа n.\n\nФакториал n! = 1 × 2 × 3 × ... × n\n\nПримеры:\n5 → 3 (5! = 120, сумма цифр 1+2+0=3)\n10 → 27 (10! = 3628800, сумма цифр 3+6+2+8+8+0+0=27)\n6 → 9 (6! = 720, сумма цифр 7+2+0=9)\n8 → 9 (8! = 40320, сумма цифр 4+0+3+2+0=9)",
    "hints": {
      "60": "Сначала вычислите факториал, затем найдите сумму цифр",
      "120": "Для больших чисел вычисляйте факториал итеративно"
    },
    "test_code": [
      "def test_factorial_sum_5(): assert factorial_digit_sum(5) == 3",
      "def test_factorial_sum_10(): assert factorial_digit_sum(10) == 27",
      "def test_factorial_sum_6(): assert factorial_digit_sum(6) == 9",
      "def test_factorial_sum_8(): assert factorial_digit_sum(8) == 9",
      "def test_factorial_sum_1(): assert factorial_digit_sum(1) == 1",
      "def test_factorial_sum_2(): assert factorial_digit_sum(2) == 2",
      "def test_factorial_sum_3(): assert factorial_digit_sum(3) == 6",
      "def test_factorial_sum_4(): assert factorial_digit_sum(4) == 6",
      "def test_factorial_sum_7(): assert factorial_digit_sum(7) == 9",
      "def test_factorial_sum_12(): assert factorial_digit_sum(12) == 27"
    ]
  },
  {
    "num": "1.4",
    "name": "Наибольший палиндром произведения",
    "code": "def largest_palindrome_product(n: int) -> int:\n    \"\"\"\n    Возвращает наибольший палиндром, который можно получить как произведение двух n-значных чисел.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию largest_palindrome_product(n: int) -> int, которая возвращает наибольший палиндром, который можно получить как произведение двух n-значных чисел.\n\nn-значные числа: от 10^(n-1) до 10^n - 1\n\nПримеры:\n2 → 9009 (99 × 91)\n1 → 9 (3 × 3)\n3 → 906609 (913 × 993)\nПримечание: Для n=2: максимальный палиндром 9009 = 99 × 91",
    "hints": {
      "60": "Перебирайте произведения от максимальных к минимальным",
      "120": "Сначала проверяйте большие числа, чтобы быстрее найти ответ"
    },
    "test_code": [
      "def test_largest_palindrome_1(): assert largest_palindrome_product(1) == 9",
      "def test_largest_palindrome_2(): assert largest_palindrome_product(2) == 9009",
      "def test_largest_palindrome_3(): assert largest_palindrome_product(3) == 906609",
      "def test_largest_palindrome_4(): assert largest_palindrome_product(4) == 99000099",
      "def test_largest_palindrome_5(): assert largest_palindrome_product(5) == 9966006699"
    ]
  },
  {
    "num": "1.5",
    "name": "Сумма кратных чисел",
    "code": "def sum_multiples(n: int) -> int:\n    \"\"\"\n    Возвращает сумму всех чисел меньше n, кратных 3 или 5.\n    \"\"\"\n    # Ваш код здесь\n    pass",
    "exclude": ["import"],
    "level": "junior",
    "task_text": "Напишите функцию sum_multiples(n: int) -> int, которая возвращает сумму всех натуральных чисел меньше n, которые делятся на 3 или 5 (или на оба).\n\nПримеры:\n10 → 23 (3, 5, 6, 9)\n15 → 45 (3, 5, 6, 9, 10, 12)\n20 → 78 (3, 5, 6, 9, 10, 12, 15, 18)\n1000 → 233168\n1 → 0",
    "hints": {
      "60": "Используйте формулу суммы арифметической прогрессии",
      "120": "Не забудьте вычесть числа, кратные 15, чтобы не учитывать их дважды"
    },
    "test_code": [
      "def test_sum_multiples_10(): assert sum_multiples(10) == 23",
      "def test_sum_multiples_15(): assert sum_multiples(15) == 45",
      "def test_sum_multiples_20(): assert sum_multiples(20) == 78",
      "def test_sum_multiples_1(): assert sum_multiples(1) == 0",
      "def test_sum_multiples_3(): assert sum_multiples(3) == 0",
      "def test_sum_multiples_6(): assert sum_multiples(6) == 8",
      "def test_sum_multiples_16(): assert sum_multiples(16) == 60",
      "def test_sum_multiples_100(): assert sum_multiples(100) == 2318",
      "def test_sum_multiples_1000(): assert sum_multiples(1000) == 233168",
      "def test_sum_multiples_30(): assert sum_multiples(30) == 195"
    ]
  },
  {
    "num": "2.1",
    "name": "Проверка скобочной последовательности",
    "code": "def is_valid_parentheses(s: str) -> bool:\n    \"\"\"\n    Проверяет, является ли строка s валидной скобочной последовательностью.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "junior",
    "task_text": "Напишите функцию is_valid_parentheses(s: str) -> bool, которая проверяет, является ли строка s валидной скобочной последовательностью.\n\nСтрока состоит только из символов '(', ')', '{', '}', '[' и ']'.\n\nПравила:\n1. Открывающие скобки должны закрываться скобками того же типа\n2. Открывающие скобки должны закрываться в правильном порядке\n\nПримеры:\n\"()\" → True\n\"()[]{}\" → True\n\"(]\" → False\n\"([)]\" → False\n\"{[]}\" → True",
    "hints": {
      "60": "Используйте стек для отслеживания открывающих скобок",
      "120": "Сопоставляйте закрывающие скобки с последней открытой в стеке"
    },
    "test_code": [
      "def test_parentheses_1(): assert is_valid_parentheses('()') == True",
      "def test_parentheses_2(): assert is_valid_parentheses('()[]{}') == True",
      "def test_parentheses_3(): assert is_valid_parentheses('(]') == False",
      "def test_parentheses_4(): assert is_valid_parentheses('([)]') == False",
      "def test_parentheses_5(): assert is_valid_parentheses('{[]}') == True",
      "def test_parentheses_6(): assert is_valid_parentheses('') == True",
      "def test_parentheses_7(): assert is_valid_parentheses('((()))') == True",
      "def test_parentheses_8(): assert is_valid_parentheses('([{}])') == True",
      "def test_parentheses_9(): assert is_valid_parentheses('([)])') == False",
      "def test_parentheses_10(): assert is_valid_parentheses(']') == False"
    ]
  },
  {
    "num": "2.2",
    "name": "Поиск пропущенного числа",
    "code": "def find_missing_number(nums: list) -> int:\n    \"\"\"\n    Находит пропущенное число в последовательности от 0 до n.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "junior",
    "task_text": "Напишите функцию find_missing_number(nums: list) -> int, которая находит пропущенное число в последовательности от 0 до n, где n = длина списка.\n\nДана последовательность из n различных чисел, взятых из диапазона [0, n]. Найдите число, отсутствующее в массиве.\n\nПримеры:\n[3,0,1] → 2\n[0,1] → 2\n[9,6,4,2,3,5,7,0,1] → 8\n[0] → 1",
    "hints": {
      "60": "Используйте математическую формулу суммы арифметической прогрессии",
      "120": "Можно использовать XOR для нахождения пропущенного числа без переполнения"
    },
    "test_code": [
      "def test_missing_1(): assert find_missing_number([3,0,1]) == 2",
      "def test_missing_2(): assert find_missing_number([0,1]) == 2",
      "def test_missing_3(): assert find_missing_number([9,6,4,2,3,5,7,0,1]) == 8",
      "def test_missing_4(): assert find_missing_number([0]) == 1",
      "def test_missing_5(): assert find_missing_number([1]) == 0",
      "def test_missing_6(): assert find_missing_number([0,1,2,3,5]) == 4",
      "def test_missing_7(): assert find_missing_number([1,2,3,4]) == 0",
      "def test_missing_8(): assert find_missing_number([0,2,3,4]) == 1",
      "def test_missing_9(): assert find_missing_number([0,1,2,3,4,6,7,8,9]) == 5",
      "def test_missing_10(): assert find_missing_number([0,1,2,3,4,5,6,7,9]) == 8"
    ]
  },
  {
    "num": "2.3",
    "name": "Поворот массива",
    "code": "def rotate_array(nums: list, k: int) -> list:\n    \"\"\"\n    Поворачивает массив nums вправо на k шагов.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию rotate_array(nums: list, k: int) -> list, которая поворачивает массив nums вправо на k шагов.\n\nПримеры:\nnums = [1,2,3,4,5,6,7], k = 3 → [5,6,7,1,2,3,4]\nnums = [-1,-100,3,99], k = 2 → [3,99,-1,-100]\nnums = [1,2], k = 3 → [2,1] (k = 3 эквивалентно k = 1 при длине 2)\nnums = [1], k = 5 → [1]",
    "hints": {
      "60": "Поворот на k вправо = поворот на n-k влево",
      "120": "Используйте тройной реверс: reverse(все), reverse(первые k), reverse(последние n-k)"
    },
    "test_code": [
      "def test_rotate_1(): assert rotate_array([1,2,3,4,5,6,7], 3) == [5,6,7,1,2,3,4]",
      "def test_rotate_2(): assert rotate_array([-1,-100,3,99], 2) == [3,99,-1,-100]",
      "def test_rotate_3(): assert rotate_array([1,2], 3) == [2,1]",
      "def test_rotate_4(): assert rotate_array([1], 5) == [1]",
      "def test_rotate_5(): assert rotate_array([1,2,3,4], 0) == [1,2,3,4]",
      "def test_rotate_6(): assert rotate_array([1,2,3,4], 4) == [1,2,3,4]",
      "def test_rotate_7(): assert rotate_array([], 3) == []",
      "def test_rotate_8(): assert rotate_array([1,2,3,4,5], 2) == [4,5,1,2,3]",
      "def test_rotate_9(): assert rotate_array([1,2,3,4,5,6], 4) == [3,4,5,6,1,2]",
      "def test_rotate_10(): assert rotate_array([1,2,3,4,5,6,7,8,9,10], 7) == [4,5,6,7,8,9,10,1,2,3]"
    ]
  },
  {
    "num": "2.4",
    "name": "Максимальная сумма подмассива",
    "code": "def max_subarray_sum(nums: list) -> int:\n    \"\"\"\n    Находит максимальную сумму непрерывного подмассива.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию max_subarray_sum(nums: list) -> int, которая находит максимальную сумму непрерывного подмассива (алгоритм Кадане).\n\nПримеры:\n[-2,1,-3,4,-1,2,1,-5,4] → 6 (подмассив [4,-1,2,1])\n[1] → 1\n[5,4,-1,7,8] → 23 (весь массив)\n[-1,-2,-3] → -1 (подмассив [-1])\n[1,2,3,-2,5] → 9",
    "hints": {
      "60": "Храните текущую сумму и максимальную сумму",
      "120": "Если текущая сумма становится отрицательной, сбрасывайте её к 0"
    },
    "test_code": [
      "def test_max_sub_1(): assert max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6",
      "def test_max_sub_2(): assert max_subarray_sum([1]) == 1",
      "def test_max_sub_3(): assert max_subarray_sum([5,4,-1,7,8]) == 23",
      "def test_max_sub_4(): assert max_subarray_sum([-1,-2,-3]) == -1",
      "def test_max_sub_5(): assert max_subarray_sum([1,2,3,-2,5]) == 9",
      "def test_max_sub_6(): assert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7",
      "def test_max_sub_7(): assert max_subarray_sum([0,0,0,0]) == 0",
      "def test_max_sub_8(): assert max_subarray_sum([2,-1,2,3,4,-5]) == 10",
      "def test_max_sub_9(): assert max_subarray_sum([-5,-4,-3,-2]) == -2",
      "def test_max_sub_10(): assert max_subarray_sum([1,-2,3,-4,5,-6,7]) == 7"
    ]
  },
  {
    "num": "2.5",
    "name": "Слияние интервалов",
    "code": "def merge_intervals(intervals: list) -> list:\n    \"\"\"\n    Объединяет все перекрывающиеся интервалы.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию merge_intervals(intervals: list) -> list, которая объединяет все перекрывающиеся интервалы.\n\nКаждый интервал представлен как [start, end]. Интервалы считаются перекрывающимися, если start нового интервала <= end предыдущего.\n\nПримеры:\n[[1,3],[2,6],[8,10],[15,18]] → [[1,6],[8,10],[15,18]]\n[[1,4],[4,5]] → [[1,5]]\n[[1,4],[0,4]] → [[0,4]]\n[[1,4],[2,3]] → [[1,4]]",
    "hints": {
      "60": "Сначала отсортируйте интервалы по start",
      "120": "Проходите по отсортированным интервалам и объединяйте, если они перекрываются"
    },
    "test_code": [
      "def test_merge_1(): assert merge_intervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]",
      "def test_merge_2(): assert merge_intervals([[1,4],[4,5]]) == [[1,5]]",
      "def test_merge_3(): assert merge_intervals([[1,4],[0,4]]) == [[0,4]]",
      "def test_merge_4(): assert merge_intervals([[1,4],[2,3]]) == [[1,4]]",
      "def test_merge_5(): assert merge_intervals([[1,4],[5,6]]) == [[1,4],[5,6]]",
      "def test_merge_6(): assert merge_intervals([]) == []",
      "def test_merge_7(): assert merge_intervals([[1,2]]) == [[1,2]]",
      "def test_merge_8(): assert merge_intervals([[1,10],[2,3],[4,5],[6,7],[8,9]]) == [[1,10]]",
      "def test_merge_9(): assert merge_intervals([[1,2],[2,3],[3,4],[4,5]]) == [[1,5]]",
      "def test_merge_10(): assert merge_intervals([[1,2],[3,4],[5,6]]) == [[1,2],[3,4],[5,6]]"
    ]
  },
  {
    "num": "2.6",
    "name": "Анаграммы",
    "code": "def is_anagram(s: str, t: str) -> bool:\n    \"\"\"\n    Проверяет, являются ли строки s и t анаграммами.\n    \"\"\"\n    pass",
    "exclude": ["import", "collections"],
    "level": "junior",
    "task_text": "Напишите функцию is_anagram(s: str, t: str) -> bool, которая проверяет, являются ли строки s и t анаграммами.\n\nАнаграмма — это слово или фраза, образованная перестановкой букв другого слова или фразы.\n\nПримеры:\n\"anagram\", \"nagaram\" → True\n\"rat\", \"car\" → False\n\"\", \"\" → True\n\"a\", \"a\" → True\n\"hello\", \"olelh\" → True",
    "hints": {
      "60": "Отсортируйте обе строки и сравните",
      "120": "Используйте словарь для подсчёта символов"
    },
    "test_code": [
      "def test_anagram_1(): assert is_anagram('anagram', 'nagaram') == True",
      "def test_anagram_2(): assert is_anagram('rat', 'car') == False",
      "def test_anagram_3(): assert is_anagram('', '') == True",
      "def test_anagram_4(): assert is_anagram('a', 'a') == True",
      "def test_anagram_5(): assert is_anagram('hello', 'olelh') == True",
      "def test_anagram_6(): assert is_anagram('listen', 'silent') == True",
      "def test_anagram_7(): assert is_anagram('abc', 'def') == False",
      "def test_anagram_8(): assert is_anagram('abc', 'abcd') == False",
      "def test_anagram_9(): assert is_anagram('aaa', 'aaa') == True",
      "def test_anagram_10(): assert is_anagram('aacc', 'ccac') == False"
    ]
  },
  {
    "num": "2.7",
    "name": "Самая длинная подстрока без повторений",
    "code": "def length_of_longest_substring(s: str) -> int:\n    \"\"\"\n    Находит длину самой длинной подстроки без повторяющихся символов.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию length_of_longest_substring(s: str) -> int, которая находит длину самой длинной подстроки без повторяющихся символов.\n\nПримеры:\n\"abcabcbb\" → 3 (\"abc\")\n\"bbbbb\" → 1 (\"b\")\n\"pwwkew\" → 3 (\"wke\" или \"kew\")\n\"\" → 0\n\"dvdf\" → 3 (\"vdf\")",
    "hints": {
      "60": "Используйте метод скользящего окна",
      "120": "Храните последнее вхождение каждого символа в словаре"
    },
    "test_code": [
      "def test_longest_sub_1(): assert length_of_longest_substring('abcabcbb') == 3",
      "def test_longest_sub_2(): assert length_of_longest_substring('bbbbb') == 1",
      "def test_longest_sub_3(): assert length_of_longest_substring('pwwkew') == 3",
      "def test_longest_sub_4(): assert length_of_longest_substring('') == 0",
      "def test_longest_sub_5(): assert length_of_longest_substring('dvdf') == 3",
      "def test_longest_sub_6(): assert length_of_longest_substring('a') == 1",
      "def test_longest_sub_7(): assert length_of_longest_substring('au') == 2",
      "def test_longest_sub_8(): assert length_of_longest_substring('abcde') == 5",
      "def test_longest_sub_9(): assert length_of_longest_substring('abba') == 2",
      "def test_longest_sub_10(): assert length_of_longest_substring('tmmzuxt') == 5"
    ]
  },
  {
    "num": "2.8",
    "name": "Обращение слов в строке",
    "code": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Обращает порядок слов в строке.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "junior",
    "task_text": "Напишите функцию reverse_words(s: str) -> str, которая обращает порядок слов в строке.\n\nСлово — это последовательность не-пробельных символов. Строка может содержать ведущие/конечные пробелы и множественные пробелы между словами.\n\nПримеры:\n\"the sky is blue\" → \"blue is sky the\"\n\"  hello world  \" → \"world hello\"\n\"a good   example\" → \"example good a\"\n\"\" → \"\"\n\"single\" → \"single\"",
    "hints": {
      "60": "Разделите строку на слова, затем объедините в обратном порядке",
      "120": "Удалите лишние пробелы при обработке"
    },
    "test_code": [
      "def test_reverse_words_1(): assert reverse_words('the sky is blue') == 'blue is sky the'",
      "def test_reverse_words_2(): assert reverse_words('  hello world  ') == 'world hello'",
      "def test_reverse_words_3(): assert reverse_words('a good   example') == 'example good a'",
      "def test_reverse_words_4(): assert reverse_words('') == ''",
      "def test_reverse_words_5(): assert reverse_words('single') == 'single'",
      "def test_reverse_words_6(): assert reverse_words('  test  ') == 'test'",
      "def test_reverse_words_7(): assert reverse_words('one   two   three') == 'three two one'",
      "def test_reverse_words_8(): assert reverse_words('multiple spaces between') == 'between spaces multiple'",
      "def test_reverse_words_9(): assert reverse_words('   ') == ''",
      "def test_reverse_words_10(): assert reverse_words('a b c d e') == 'e d c b a'"
    ]
  },
  {
    "num": "2.9",
    "name": "Проверка степени двойки",
    "code": "def is_power_of_two(n: int) -> bool:\n    \"\"\"\n    Проверяет, является ли число степенью двойки.\n    \"\"\"\n    pass",
    "exclude": ["import", "math"],
    "level": "junior",
    "task_text": "Напишите функцию is_power_of_two(n: int) -> bool, которая проверяет, является ли положительное целое число степенью двойки.\n\nПримеры:\n1 → True (2⁰)\n16 → True (2⁴)\n3 → False\n0 → False (по определению)\n1024 → True\n-8 → False (только положительные числа)",
    "hints": {
      "60": "Степень двойки имеет только одну единицу в двоичном представлении",
      "120": "Используйте побитовые операции: n & (n-1) == 0 для n > 0"
    },
    "test_code": [
      "def test_power_two_1(): assert is_power_of_two(1) == True",
      "def test_power_two_2(): assert is_power_of_two(16) == True",
      "def test_power_two_3(): assert is_power_of_two(3) == False",
      "def test_power_two_4(): assert is_power_of_two(0) == False",
      "def test_power_two_5(): assert is_power_of_two(1024) == True",
      "def test_power_two_6(): assert is_power_of_two(-8) == False",
      "def test_power_two_7(): assert is_power_of_two(64) == True",
      "def test_power_two_8(): assert is_power_of_two(128) == True",
      "def test_power_two_9(): assert is_power_of_two(100) == False",
      "def test_power_two_10(): assert is_power_of_two(256) == True"
    ]
  },
  {
    "num": "2.10",
    "name": "Обращение целого числа",
    "code": "def reverse_integer(x: int) -> int:\n    \"\"\"\n    Обращает цифры целого числа.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "junior",
    "task_text": "Напишите функцию reverse_integer(x: int) -> int, которая обращает цифры целого числа.\n\nЕсли обращённое число выходит за пределы 32-битного целого со знаком [-2³¹, 2³¹-1], верните 0.\n\nПримеры:\n123 → 321\n-123 → -321\n120 → 21\n0 → 0\n1534236469 → 0 (выходит за пределы)\n-2147483648 → 0",
    "hints": {
      "60": "Работайте с абсолютным значением числа",
      "120": "Проверяйте переполнение перед возвратом результата"
    },
    "test_code": [
      "def test_reverse_int_1(): assert reverse_integer(123) == 321",
      "def test_reverse_int_2(): assert reverse_integer(-123) == -321",
      "def test_reverse_int_3(): assert reverse_integer(120) == 21",
      "def test_reverse_int_4(): assert reverse_integer(0) == 0",
      "def test_reverse_int_5(): assert reverse_integer(1534236469) == 0",
      "def test_reverse_int_6(): assert reverse_integer(-2147483648) == 0",
      "def test_reverse_int_7(): assert reverse_integer(901000) == 109",
      "def test_reverse_int_8(): assert reverse_integer(2147483647) == 0",
      "def test_reverse_int_9(): assert reverse_integer(-901000) == -109",
      "def test_reverse_int_10(): assert reverse_integer(1000000003) == 0"
    ]
  },
  {
    "num": "2.11",
    "name": "Римские цифры в целое",
    "code": "def roman_to_int(s: str) -> int:\n    \"\"\"\n    Преобразует римское число в целое.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию roman_to_int(s: str) -> int, которая преобразует римское число в целое.\n\nПравила:\nI = 1, V = 5, X = 10, L = 50, C = 100, D = 500, M = 1000\nЕсли меньшая цифра стоит перед большей, она вычитается\n\nПримеры:\n\"III\" → 3\n\"IV\" → 4\n\"IX\" → 9\n\"LVIII\" → 58\n\"MCMXCIV\" → 1994",
    "hints": {
      "60": "Проходите строку справа налево",
      "120": "Если текущий символ меньше предыдущего, вычитайте его значение"
    },
    "test_code": [
      "def test_roman_1(): assert roman_to_int('III') == 3",
      "def test_roman_2(): assert roman_to_int('IV') == 4",
      "def test_roman_3(): assert roman_to_int('IX') == 9",
      "def test_roman_4(): assert roman_to_int('LVIII') == 58",
      "def test_roman_5(): assert roman_to_int('MCMXCIV') == 1994",
      "def test_roman_6(): assert roman_to_int('I') == 1",
      "def test_roman_7(): assert roman_to_int('MMXXIII') == 2023",
      "def test_roman_8(): assert roman_to_int('XL') == 40",
      "def test_roman_9(): assert roman_to_int('XC') == 90",
      "def test_roman_10(): assert roman_to_int('CD') == 400"
    ]
  },
  {
    "num": "2.12",
    "name": "Целое в римские цифры",
    "code": "def int_to_roman(num: int) -> str:\n    \"\"\"\n    Преобразует целое число в римское.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию int_to_roman(num: int) -> str, которая преобразует целое число от 1 до 3999 в римское.\n\nПравила:\nI=1, V=5, X=10, L=50, C=100, D=500, M=1000\nЧисла записываются как комбинации символов, где меньшие могут стоять перед большими для вычитания\n\nПримеры:\n3 → \"III\"\n4 → \"IV\"\n9 → \"IX\"\n58 → \"LVIII\"\n1994 → \"MCMXCIV\"",
    "hints": {
      "60": "Используйте словарь с парами значение-символ в порядке убывания",
      "120": "Для каждой пары добавляйте символ, пока число >= значению"
    },
    "test_code": [
      "def test_int_roman_1(): assert int_to_roman(3) == 'III'",
      "def test_int_roman_2(): assert int_to_roman(4) == 'IV'",
      "def test_int_roman_3(): assert int_to_roman(9) == 'IX'",
      "def test_int_roman_4(): assert int_to_roman(58) == 'LVIII'",
      "def test_int_roman_5(): assert int_to_roman(1994) == 'MCMXCIV'",
      "def test_int_roman_6(): assert int_to_roman(1) == 'I'",
      "def test_int_roman_7(): assert int_to_roman(2023) == 'MMXXIII'",
      "def test_int_roman_8(): assert int_to_roman(40) == 'XL'",
      "def test_int_roman_9(): assert int_to_roman(90) == 'XC'",
      "def test_int_roman_10(): assert int_to_roman(3999) == 'MMMCMXCIX'"
    ]
  },
  {
    "num": "2.13",
    "name": "Счастливые билеты",
    "code": "def lucky_tickets_count(n: int) -> int:\n    \"\"\"\n    Считает количество счастливых билетов для n-значных чисел.\n    \"\"\"\n    pass",
    "exclude": ["import", "math"],
    "level": "hard",
    "task_text": "Напишите функцию lucky_tickets_count(n: int) -> int, которая считает количество счастливых n-значных билетов.\n\nСчастливым считается билет, у которого сумма первых n/2 цифр равна сумме последних n/2 цифр.\nЧисло n всегда чётное. Билеты могут начинаться с нуля.\n\nПримеры:\nn=2 → 10 (00, 11, 22, 33, 44, 55, 66, 77, 88, 99)\nn=4 → 670\nn=6 → 55252\nn=8 → 4816030",
    "hints": {
      "60": "Используйте динамическое программирование для подсчёта сумм",
      "120": "Для каждой возможной суммы считайте количество способов её получить"
    },
    "test_code": [
      "def test_lucky_2(): assert lucky_tickets_count(2) == 10",
      "def test_lucky_4(): assert lucky_tickets_count(4) == 670",
      "def test_lucky_6(): assert lucky_tickets_count(6) == 55252",
      "def test_lucky_8(): assert lucky_tickets_count(8) == 4816030",
      "def test_lucky_10(): assert lucky_tickets_count(10) == 432457640"
    ]
  },
  {
    "num": "2.14",
    "name": "Поиск пикового элемента",
    "code": "def find_peak_element(nums: list) -> int:\n    \"\"\"\n    Находит индекс любого пикового элемента в массиве.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию find_peak_element(nums: list) -> int, которая находит индекс любого пикового элемента в массиве.\n\nПиковый элемент — это элемент, который больше своих соседей. Для граничных элементов достаточно быть больше одного соседа.\n\nПримеры:\n[1,2,3,1] → 2 (элемент 3)\n[1,2,1,3,5,6,4] → 1 или 5 (элементы 2 или 6)\n[1] → 0\n[1,2] → 1\n[2,1] → 0",
    "hints": {
      "60": "Используйте бинарный поиск",
      "120": "Если серединный элемент меньше правого соседа, пик находится справа"
    },
    "test_code": [
      "def test_peak_1(): assert find_peak_element([1,2,3,1]) == 2",
      "def test_peak_2(): result = find_peak_element([1,2,1,3,5,6,4]); assert result in [1,5]",
      "def test_peak_3(): assert find_peak_element([1]) == 0",
      "def test_peak_4(): assert find_peak_element([1,2]) == 1",
      "def test_peak_5(): assert find_peak_element([2,1]) == 0",
      "def test_peak_6(): result = find_peak_element([1,3,2,1]); assert result == 1",
      "def test_peak_7(): assert find_peak_element([1,2,3,4,5]) == 4",
      "def test_peak_8(): assert find_peak_element([5,4,3,2,1]) == 0",
      "def test_peak_9(): result = find_peak_element([1,6,5,4,3,2,1]); assert result == 1",
      "def test_peak_10(): assert find_peak_element([1,2,3,4,3,2,1]) == 3"
    ]
  },
  {
    "num": "2.15",
    "name": "Вращение матрицы",
    "code": "def rotate_matrix(matrix: list) -> list:\n    \"\"\"\n    Поворачивает матрицу на 90 градусов по часовой стрелке.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию rotate_matrix(matrix: list) -> list, которая поворачивает квадратную матрицу n×n на 90 градусов по часовой стрелке.\n\nПримеры:\n[[1,2,3],[4,5,6],[7,8,9]] → [[7,4,1],[8,5,2],[9,6,3]]\n[[1,2],[3,4]] → [[3,1],[4,2]]\n[[1]] → [[1]]\n[] → []",
    "hints": {
      "60": "Транспонируйте матрицу, затем отразите по вертикали",
      "120": "Можно вращать попиксельно: matrix[i][j] → matrix[j][n-1-i]"
    },
    "test_code": [
      "def test_rotate_matrix_1(): assert rotate_matrix([[1,2,3],[4,5,6],[7,8,9]]) == [[7,4,1],[8,5,2],[9,6,3]]",
      "def test_rotate_matrix_2(): assert rotate_matrix([[1,2],[3,4]]) == [[3,1],[4,2]]",
      "def test_rotate_matrix_3(): assert rotate_matrix([[1]]) == [[1]]",
      "def test_rotate_matrix_4(): assert rotate_matrix([]) == []",
      "def test_rotate_matrix_5(): assert rotate_matrix([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) == [[13,9,5,1],[14,10,6,2],[15,11,7,3],[16,12,8,4]]",
      "def test_rotate_matrix_6(): assert rotate_matrix([[1,2,3],[4,5,6],[7,8,9]]) == [[7,4,1],[8,5,2],[9,6,3]]",
      "def test_rotate_matrix_7(): assert rotate_matrix([[1,2],[3,4]]) == [[3,1],[4,2]]",
      "def test_rotate_matrix_8(): assert rotate_matrix([[1,2,3],[4,5,6],[7,8,9]]) == [[7,4,1],[8,5,2],[9,6,3]]",
      "def test_rotate_matrix_9(): assert rotate_matrix([[1]]) == [[1]]",
      "def test_rotate_matrix_10(): assert rotate_matrix([[]]) == [[]]"
    ]
  },
  {
    "num": "2.16",
    "name": "Спиральный обход матрицы",
    "code": "def spiral_order(matrix: list) -> list:\n    \"\"\"\n    Возвращает элементы матрицы в порядке спирального обхода.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию spiral_order(matrix: list) -> list, которая возвращает элементы матрицы m×n в порядке спирального обхода (по часовой стрелке, начиная с верхнего левого угла).\n\nПримеры:\n[[1,2,3],[4,5,6],[7,8,9]] → [1,2,3,6,9,8,7,4,5]\n[[1,2,3,4],[5,6,7,8],[9,10,11,12]] → [1,2,3,4,8,12,11,10,9,5,6,7]\n[[1]] → [1]\n[] → []",
    "hints": {
      "60": "Определите границы: top, bottom, left, right",
      "120": "Проходите по периметру, затем сдвигайте границы внутрь"
    },
    "test_code": [
      "def test_spiral_1(): assert spiral_order([[1,2,3],[4,5,6],[7,8,9]]) == [1,2,3,6,9,8,7,4,5]",
      "def test_spiral_2(): assert spiral_order([[1,2,3,4],[5,6,7,8],[9,10,11,12]]) == [1,2,3,4,8,12,11,10,9,5,6,7]",
      "def test_spiral_3(): assert spiral_order([[1]]) == [1]",
      "def test_spiral_4(): assert spiral_order([]) == []",
      "def test_spiral_5(): assert spiral_order([[1,2],[3,4],[5,6],[7,8]]) == [1,2,4,6,8,7,5,3]",
      "def test_spiral_6(): assert spiral_order([[1,2,3]]) == [1,2,3]",
      "def test_spiral_7(): assert spiral_order([[1],[2],[3]]) == [1,2,3]",
      "def test_spiral_8(): assert spiral_order([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) == [1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]",
      "def test_spiral_9(): assert spiral_order([[1,2],[3,4]]) == [1,2,4,3]",
      "def test_spiral_10(): assert spiral_order([[]]) == []"
    ]
  },
  {
    "num": "3.1",
    "name": "Шарики (Yandex)",
    "code": "def min_balloons(colors: str) -> int:\n    \"\"\"\n    Минимальное количество шаров для сборки строки colors.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "junior",
    "task_text": "Напишите функцию min_balloons(colors: str) -> int, которая возвращает минимальное количество шаров, необходимое для сборки строки colors.\n\nУ вас есть неограниченное количество шаров каждого цвета. Каждый шар содержит одну букву (цвет). Строка colors должна быть собрана как последовательность шаров.\n\nПримеры:\n\"RRBB\" → 4 (нужно 2 красных и 2 синих шара)\n\"RRRR\" → 4\n\"RGB\" → 3\n\"RBRB\" → 4\n\"\" → 0",
    "hints": {
      "60": "Просто подсчитайте количество каждого цвета",
      "120": "Максимальное количество шаров одного цвета = частота этого цвета"
    },
    "test_code": [
      "def test_balloons_1(): assert min_balloons('RRBB') == 4",
      "def test_balloons_2(): assert min_balloons('RRRR') == 4",
      "def test_balloons_3(): assert min_balloons('RGB') == 3",
      "def test_balloons_4(): assert min_balloons('RBRB') == 4",
      "def test_balloons_5(): assert min_balloons('') == 0",
      "def test_balloons_6(): assert min_balloons('RRGGBB') == 6",
      "def test_balloons_7(): assert min_balloons('RRRGGGBBB') == 9",
      "def test_balloons_8(): assert min_balloons('RGBRGB') == 6",
      "def test_balloons_9(): assert min_balloons('RRRRRR') == 6",
      "def test_balloons_10(): assert min_balloons('RBG') == 3"
    ]
  },
  {
    "num": "3.2",
    "name": "Сумма на подотрезках (Yandex)",
    "code": "def subarray_sums(arr: list, k: int) -> int:\n    \"\"\"\n    Количество подмассивов с суммой равной k.\n    \"\"\"\n    pass",
    "exclude": ["import", "collections"],
    "level": "middle",
    "task_text": "Напишите функцию subarray_sums(arr: list, k: int) -> int, которая возвращает количество непрерывных подмассивов, сумма элементов которых равна k.\n\nПримеры:\n[1,1,1], k=2 → 2 (подмассивы [1,1] и [1,1])\n[1,2,3], k=3 → 2 (подмассивы [1,2] и [3])\n[10,5,7,1,2], k=15 → 1 (подмассив [10,5])\n[1,-1,0], k=0 → 3\n[], k=0 → 0",
    "hints": {
      "60": "Используйте префиксные суммы",
      "120": "Храните частоту префиксных сумм в словаре"
    },
    "test_code": [
      "def test_subarray_1(): assert subarray_sums([1,1,1], 2) == 2",
      "def test_subarray_2(): assert subarray_sums([1,2,3], 3) == 2",
      "def test_subarray_3(): assert subarray_sums([10,5,7,1,2], 15) == 1",
      "def test_subarray_4(): assert subarray_sums([1,-1,0], 0) == 3",
      "def test_subarray_5(): assert subarray_sums([], 0) == 0",
      "def test_subarray_6(): assert subarray_sums([1], 1) == 1",
      "def test_subarray_7(): assert subarray_sums([0,0,0,0], 0) == 10",
      "def test_subarray_8(): assert subarray_sums([3,4,7,2,-3,1,4,2], 7) == 4",
      "def test_subarray_9(): assert subarray_sums([1,2,3,4,5], 9) == 2",
      "def test_subarray_10(): assert subarray_sums([-1,-1,1], 0) == 1"
    ]
  },
  {
    "num": "3.3",
    "name": "Скобочный баланс (Google Code Jam)",
    "code": "def min_swaps(s: str) -> int:\n    \"\"\"\n    Минимальное количество обменов для сбалансированной строки.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию min_swaps(s: str) -> int, которая возвращает минимальное количество обменов соседних символов, чтобы сделать строку сбалансированной.\n\nСтрока состоит только из символов '[' и ']'. Сбалансированная строка: количество '[' равно количеству ']' и в любом префиксе количество '[' >= количеству ']'.\n\nПримеры:\n\"][][\" → 1 (меняем первые два символа)\n\"]]][[[\" → 2\n\"[]\" → 0\n\"][\" → 1\n\"\" → 0",
    "hints": {
      "60": "Считайте баланс: +1 для '[', -1 для ']'",
      "120": "Когда баланс становится -1, нужно найти следующую '[' для обмена"
    },
    "test_code": [
      "def test_swaps_1(): assert min_swaps('][][') == 1",
      "def test_swaps_2(): assert min_swaps(']]][[[') == 2",
      "def test_swaps_3(): assert min_swaps('[]') == 0",
      "def test_swaps_4(): assert min_swaps('][') == 1",
      "def test_swaps_5(): assert min_swaps('') == 0",
      "def test_swaps_6(): assert min_swaps('[[]]') == 0",
      "def test_swaps_7(): assert min_swaps(']][[') == 2",
      "def test_swaps_8(): assert min_swaps('][[]][') == 2",
      "def test_swaps_9(): assert min_swaps('[[][]]') == 0",
      "def test_swaps_10(): assert min_swaps(']]][[[]][[') == 3"
    ]
  },
  {
    "num": "3.4",
    "name": "Сортировка по частоте (Yandex)",
    "code": "def frequency_sort(s: str) -> str:\n    \"\"\"\n    Сортирует символы строки по убыванию частоты.\n    \"\"\"\n    pass",
    "exclude": ["import", "collections"],
    "level": "middle",
    "task_text": "Напишите функцию frequency_sort(s: str) -> str, которая возвращает строку с символами, отсортированными по убыванию частоты.\n\nЕсли несколько символов имеют одинаковую частоту, они должны сохранить исходный порядок (стабильная сортировка).\n\nПримеры:\n\"tree\" → \"eetr\" или \"eert\" (e:2, t:1, r:1)\n\"cccaaa\" → \"cccaaa\" или \"aaaccc\" (c:3, a:3)\n\"Aabb\" → \"bbAa\" (b:2, A:1, a:1)\n\"\" → \"\"",
    "hints": {
      "60": "Подсчитайте частоту каждого символа",
      "120": "Используйте стабильную сортировку по убыванию частоты"
    },
    "test_code": [
      "def test_freq_1(): result = frequency_sort('tree'); assert result.count('e') == 2 and result.count('t') == 1 and result.count('r') == 1",
      "def test_freq_2(): result = frequency_sort('cccaaa'); assert (result == 'cccaaa' or result == 'aaaccc')",
      "def test_freq_3(): result = frequency_sort('Aabb'); assert result.count('b') == 2",
      "def test_freq_4(): assert frequency_sort('') == ''",
      "def test_freq_5(): result = frequency_sort('loveleetcode'); assert result[0] == 'e' and result.count('e') == 4",
      "def test_freq_6(): result = frequency_sort('raaeaedere'); assert result[0] == 'e' and result[1] == 'e'",
      "def test_freq_7(): result = frequency_sort('dddbbb'); assert result.startswith('ddd') or result.startswith('bbb')",
      "def test_freq_8(): result = frequency_sort('abc'); assert set(result) == {'a','b','c'}",
      "def test_freq_9(): result = frequency_sort('aaabb'); assert result.startswith('aaa')",
      "def test_freq_10(): result = frequency_sort('abacc'); assert result[0] == 'a' and result[1] == 'a'"
    ]
  },
  {
    "num": "3.5",
    "name": "Прыжки по облакам (Google)",
    "code": "def min_jumps(clouds: list) -> int:\n    \"\"\"\n    Минимальное количество прыжков по облакам.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "junior",
    "task_text": "Напишите функцию min_jumps(clouds: list) -> int, которая возвращает минимальное количество прыжков для прохождения облаков.\n\nОблака пронумерованы 0..n-1. Игрок начинает на облаке 0 и должен достичь облака n-1.\nОблака бывают двух типов: 0 - безопасное, 1 - грозовое (на него нельзя прыгать).\nМожно прыгать на 1 или 2 облака вперед. Всегда гарантируется, что решение существует.\n\nПримеры:\n[0,1,0,0,0,1,0] → 3 (0→2→4→6)\n[0,0,1,0,0,1,0] → 4 (0→1→3→4→6)\n[0,0,0,0,1,0] → 3 (0→2→3→5)\n[0,0] → 1",
    "hints": {
      "60": "Используйте динамическое программирование",
      "120": "Для каждого облака проверяйте, можно ли прийти с предыдущих облаков"
    },
    "test_code": [
      "def test_jumps_1(): assert min_jumps([0,1,0,0,0,1,0]) == 3",
      "def test_jumps_2(): assert min_jumps([0,0,1,0,0,1,0]) == 4",
      "def test_jumps_3(): assert min_jumps([0,0,0,0,1,0]) == 3",
      "def test_jumps_4(): assert min_jumps([0,0]) == 1",
      "def test_jumps_5(): assert min_jumps([0,1,0]) == 1",
      "def test_jumps_6(): assert min_jumps([0,0,0,1,0,0]) == 3",
      "def test_jumps_7(): assert min_jumps([0]) == 0",
      "def test_jumps_8(): assert min_jumps([0,0,0,0,0]) == 2",
      "def test_jumps_9(): assert min_jumps([0,0,1,0,0,0,0,1,0,0]) == 6",
      "def test_jumps_10(): assert min_jumps([0,1,0,1,0,1,0,0]) == 4"
    ]
  },
  {
    "num": "3.6",
    "name": "Повторяющаяся ДНК (Google)",
    "code": "def find_repeated_dna_sequences(s: str) -> list:\n    \"\"\"\n    Находит все 10-символьные последовательности, которые встречаются более одного раза.\n    \"\"\"\n    pass",
    "exclude": ["import", "collections"],
    "level": "middle",
    "task_text": "Напишите функцию find_repeated_dna_sequences(s: str) -> list, которая находит все 10-символьные последовательности (подстроки), которые встречаются в строке ДНК более одного раза.\n\nСтрока состоит только из символов 'A', 'C', 'G', 'T'.\n\nПримеры:\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\" → [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n\"AAAAAAAAAAAAA\" → [\"AAAAAAAAAA\"]\n\"ACG\" → []\n\"\" → []",
    "hints": {
      "60": "Используйте скользящее окно длиной 10",
      "120": "Храните встреченные последовательности в множестве"
    },
    "test_code": [
      "def test_dna_1(): assert sorted(find_repeated_dna_sequences('AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT')) == sorted(['AAAAACCCCC','CCCCCAAAAA'])",
      "def test_dna_2(): assert find_repeated_dna_sequences('AAAAAAAAAAAAA') == ['AAAAAAAAAA']",
      "def test_dna_3(): assert find_repeated_dna_sequences('ACG') == []",
      "def test_dna_4(): assert find_repeated_dna_sequences('') == []",
      "def test_dna_5(): assert find_repeated_dna_sequences('AAAAACCCCCAAAAACCCCCC') == ['AAAAACCCCC']",
      "def test_dna_6(): assert find_repeated_dna_sequences('AAAAAAAAAAA') == ['AAAAAAAAAA']",
      "def test_dna_7(): assert find_repeated_dna_sequences('ACGTACGTAC') == []",
      "def test_dna_8(): assert find_repeated_dna_sequences('ACGTACGTACGTACGTACGT') == ['ACGTACGTAC']",
      "def test_dna_9(): assert find_repeated_dna_sequences('ACGT'*5) == []",
      "def test_dna_10(): assert find_repeated_dna_sequences('AAAAACCCCCAAAAACCCCCCAAAAACCCCCC') == ['AAAAACCCCC','CCCCCAAAAA']"
    ]
  },
  {
    "num": "3.7",
    "name": "Максимальный продукт подмассива (Google)",
    "code": "def max_product_subarray(nums: list) -> int:\n    \"\"\"\n    Находит максимальное произведение непрерывного подмассива.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "hard",
    "task_text": "Напишите функцию max_product_subarray(nums: list) -> int, которая находит максимальное произведение непрерывного подмассива.\n\nМассив может содержать отрицательные числа и нули.\n\nПримеры:\n[2,3,-2,4] → 6 (подмассив [2,3])\n[-2,0,-1] → 0\n[-2,3,-4] → 24 (весь массив)\n[0,2] → 2\n[-2] → -2",
    "hints": {
      "60": "Храните минимальное и максимальное произведение на каждом шаге",
      "120": "При встрече отрицательного числа меняйте местами min и max"
    },
    "test_code": [
      "def test_max_product_1(): assert max_product_subarray([2,3,-2,4]) == 6",
      "def test_max_product_2(): assert max_product_subarray([-2,0,-1]) == 0",
      "def test_max_product_3(): assert max_product_subarray([-2,3,-4]) == 24",
      "def test_max_product_4(): assert max_product_subarray([0,2]) == 2",
      "def test_max_product_5(): assert max_product_subarray([-2]) == -2",
      "def test_max_product_6(): assert max_product_subarray([-1,-2,-3]) == 6",
      "def test_max_product_7(): assert max_product_subarray([1,2,3,4]) == 24",
      "def test_max_product_8(): assert max_product_subarray([-1,-1,-2,-3]) == 6",
      "def test_max_product_9(): assert max_product_subarray([3,-1,4]) == 4",
      "def test_max_product_10(): assert max_product_subarray([2,-5,-2,-4,3]) == 24"
    ]
  },
  {
    "num": "3.8",
    "name": "Реверс слов в строке II (Google)",
    "code": "def reverse_words_ii(s: list) -> None:\n    \"\"\"\n    Обращает слова в строке на месте.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию reverse_words_ii(s: list) -> None, которая обращает порядок слов в строке на месте.\n\nСтрока представлена как список символов. Не используйте дополнительную память.\n\nПримеры:\n[\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"] →\n[\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"]\n[\"a\"] → [\"a\"]\n[] → []",
    "hints": {
      "60": "Сначала реверс всей строки, затем реверс каждого слова",
      "120": "Используйте два указателя для определения границ слов"
    },
    "test_code": [
      "def test_reverse_ii_1():\n        s = list(\"the sky is blue\")\n        reverse_words_ii(s)\n        assert s == list(\"blue is sky the\")",
      "def test_reverse_ii_2():\n        s = list(\"a\")\n        reverse_words_ii(s)\n        assert s == list(\"a\")",
      "def test_reverse_ii_3():\n        s = []\n        reverse_words_ii(s)\n        assert s == []",
      "def test_reverse_ii_4():\n        s = list(\"hello world\")\n        reverse_words_ii(s)\n        assert s == list(\"world hello\")",
      "def test_reverse_ii_5():\n        s = list(\"a b c d\")\n        reverse_words_ii(s)\n        assert s == list(\"d c b a\")",
      "def test_reverse_ii_6():\n        s = list(\"  hello  world  \")\n        reverse_words_ii(s)\n        assert s == list(\"  world  hello  \")",
      "def test_reverse_ii_7():\n        s = list(\"the\")\n        reverse_words_ii(s)\n        assert s == list(\"the\")",
      "def test_reverse_ii_8():\n        s = list(\"a good example\")\n        reverse_words_ii(s)\n        assert s == list(\"example good a\")",
      "def test_reverse_ii_9():\n        s = list(\"Bob likes Alice\")\n        reverse_words_ii(s)\n        assert s == list(\"Alice likes Bob\")",
      "def test_reverse_ii_10():\n        s = list(\"multiple   spaces   between\")\n        reverse_words_ii(s)\n        assert s == list(\"between   spaces   multiple\")"
    ]
  },
  {
    "num": "3.9",
    "name": "Проверка палиндрома II (Google)",
    "code": "def valid_palindrome_ii(s: str) -> bool:\n    \"\"\"\n    Проверяет, можно ли сделать строку палиндромом удалением одного символа.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "middle",
    "task_text": "Напишите функцию valid_palindrome_ii(s: str) -> bool, которая проверяет, можно ли сделать строку палиндромом удалением не более одного символа.\n\nПримеры:\n\"aba\" → True (уже палиндром)\n\"abca\" → True (удалить 'c')\n\"abc\" → False\n\"\" → True\n\"a\" → True\n\"deeee\" → True",
    "hints": {
      "60": "Используйте два указателя с начала и конца",
      "120": "При первом несовпадении проверьте оба варианта: удаление левого или правого символа"
    },
    "test_code": [
      "def test_palindrome_ii_1(): assert valid_palindrome_ii('aba') == True",
      "def test_palindrome_ii_2(): assert valid_palindrome_ii('abca') == True",
      "def test_palindrome_ii_3(): assert valid_palindrome_ii('abc') == False",
      "def test_palindrome_ii_4(): assert valid_palindrome_ii('') == True",
      "def test_palindrome_ii_5(): assert valid_palindrome_ii('a') == True",
      "def test_palindrome_ii_6(): assert valid_palindrome_ii('deeee') == True",
      "def test_palindrome_ii_7(): assert valid_palindrome_ii('cbbcc') == True",
      "def test_palindrome_ii_8(): assert valid_palindrome_ii('eeccccbebaeeabebccceea') == False",
      "def test_palindrome_ii_9(): assert valid_palindrome_ii('ab') == True",
      "def test_palindrome_ii_10(): assert valid_palindrome_ii('aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga') == True"
    ]
  },
  {
    "num": "3.10",
    "name": "Слияние k отсортированных списков (Google)",
    "code": "def merge_k_lists(lists: list) -> list:\n    \"\"\"\n    Объединяет k отсортированных списков в один отсортированный список.\n    \"\"\"\n    pass",
    "exclude": ["import", "heapq"],
    "level": "hard",
    "task_text": "Напишите функцию merge_k_lists(lists: list) -> list, которая объединяет k отсортированных по возрастанию списков в один отсортированный список.\n\nПримеры:\n[[1,4,5],[1,3,4],[2,6]] → [1,1,2,3,4,4,5,6]\n[] → []\n[[]] → []\n[[1],[0]] → [0,1]\n[[-10,-9,-9,-3,-1,-1,0],[-5],[4],[-8],[],[-9,-6,-5,-4,-2,2,3],[-3,-3,-2,-1,0]] → [-10,-9,-9,-9,-8,-6,-5,-5,-4,-3,-3,-3,-2,-2,-1,-1,-1,0,0,2,3,4]",
    "hints": {
      "60": "Используйте алгоритм слияния попарно",
      "120": "Можно хранить текущие элементы из каждого списка и выбирать минимальный"
    },
    "test_code": [
      "def test_merge_k_1(): assert merge_k_lists([[1,4,5],[1,3,4],[2,6]]) == [1,1,2,3,4,4,5,6]",
      "def test_merge_k_2(): assert merge_k_lists([]) == []",
      "def test_merge_k_3(): assert merge_k_lists([[]]) == []",
      "def test_merge_k_4(): assert merge_k_lists([[1],[0]]) == [0,1]",
      "def test_merge_k_5(): \n        result = merge_k_lists([[-10,-9,-9,-3,-1,-1,0],[-5],[4],[-8],[],[-9,-6,-5,-4,-2,2,3],[-3,-3,-2,-1,0]])\n        expected = [-10,-9,-9,-9,-8,-6,-5,-5,-4,-3,-3,-3,-2,-2,-1,-1,-1,0,0,2,3,4]\n        assert result == expected",
      "def test_merge_k_6(): assert merge_k_lists([[1,2,3],[4,5,6],[7,8,9]]) == [1,2,3,4,5,6,7,8,9]",
      "def test_merge_k_7(): assert merge_k_lists([[1],[2],[3]]) == [1,2,3]",
      "def test_merge_k_8(): assert merge_k_lists([[1,3,5],[2,4,6]]) == [1,2,3,4,5,6]",
      "def test_merge_k_9(): assert merge_k_lists([[10,20],[15,25],[5,30]]) == [5,10,15,20,25,30]",
      "def test_merge_k_10(): assert merge_k_lists([[],[1],[2,3]]) == [1,2,3]"
    ]
  },
  {
    "num": "3.11",
    "name": "Треугольник Паскаля (Yandex)",
    "code": "def generate_pascal_triangle(num_rows: int) -> list:\n    \"\"\"\n    Генерирует треугольник Паскаля с заданным количеством строк.\n    \"\"\"\n    pass",
    "exclude": ["import", "math"],
    "level": "junior",
    "task_text": "Напишите функцию generate_pascal_triangle(num_rows: int) -> list, которая генерирует треугольник Паскаля с заданным количеством строк.\n\nКаждая строка треугольника представляет собой список чисел.\n\nПримеры:\n5 → [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n1 → [[1]]\n0 → []\n3 → [[1],[1,1],[1,2,1]]",
    "hints": {
      "60": "Каждое число равно сумме двух чисел над ним",
      "120": "Начинайте с первой строки [1], затем генерируйте следующие"
    },
    "test_code": [
      "def test_pascal_1(): assert generate_pascal_triangle(5) == [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
      "def test_pascal_2(): assert generate_pascal_triangle(1) == [[1]]",
      "def test_pascal_3(): assert generate_pascal_triangle(0) == []",
      "def test_pascal_4(): assert generate_pascal_triangle(3) == [[1],[1,1],[1,2,1]]",
      "def test_pascal_5(): assert generate_pascal_triangle(6) == [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1]]",
      "def test_pascal_6(): assert generate_pascal_triangle(2) == [[1],[1,1]]",
      "def test_pascal_7(): assert generate_pascal_triangle(4) == [[1],[1,1],[1,2,1],[1,3,3,1]]",
      "def test_pascal_8(): assert generate_pascal_triangle(7)[6] == [1,6,15,20,15,6,1]",
      "def test_pascal_9(): assert len(generate_pascal_triangle(8)) == 8",
      "def test_pascal_10(): assert generate_pascal_triangle(10)[9][5] == 126"
    ]
  },
  {
    "num": "3.12",
    "name": "Сумма двух чисел (Google)",
    "code": "def two_sum(nums: list, target: int) -> list:\n    \"\"\"\n    Находит индексы двух чисел, сумма которых равна target.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "junior",
    "task_text": "Напишите функцию two_sum(nums: list, target: int) -> list, которая находит индексы двух различных чисел в массиве, сумма которых равна target.\n\nГарантируется, что существует ровно одно решение. Нельзя использовать один и тот же элемент дважды.\n\nПримеры:\n[2,7,11,15], target=9 → [0,1]\n[3,2,4], target=6 → [1,2]\n[3,3], target=6 → [0,1]\n[1,2,3,4], target=7 → [2,3]",
    "hints": {
      "60": "Используйте хэш-таблицу для хранения пройденных чисел",
      "120": "Для каждого числа ищите complement = target - num в словаре"
    },
    "test_code": [
      "def test_two_sum_1(): assert sorted(two_sum([2,7,11,15], 9)) == [0,1]",
      "def test_two_sum_2(): assert sorted(two_sum([3,2,4], 6)) == [1,2]",
      "def test_two_sum_3(): assert sorted(two_sum([3,3], 6)) == [0,1]",
      "def test_two_sum_4(): assert sorted(two_sum([1,2,3,4], 7)) == [2,3]",
      "def test_two_sum_5(): assert sorted(two_sum([0,4,3,0], 0)) == [0,3]",
      "def test_two_sum_6(): assert sorted(two_sum([-1,-2,-3,-4,-5], -8)) == [2,4]",
      "def test_two_sum_7(): assert sorted(two_sum([1,5,3,7], 8)) == [0,3]",
      "def test_two_sum_8(): assert sorted(two_sum([10,20,30,40], 50)) == [1,2]",
      "def test_two_sum_9(): assert sorted(two_sum([6,2,8,1,9], 10)) == [0,4]",
      "def test_two_sum_10(): assert sorted(two_sum([100,200,300], 500)) == [1,2]"
    ]
  },
  {
    "num": "3.13",
    "name": "Три сумма (Google)",
    "code": "def three_sum(nums: list) -> list:\n    \"\"\"\n    Находит все уникальные тройки, сумма которых равна 0.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "hard",
    "task_text": "Напишите функцию three_sum(nums: list) -> list, которая находит все уникальные тройки [nums[i], nums[j], nums[k]] такие, что i != j != k и nums[i] + nums[j] + nums[k] = 0.\n\nРешение не должно содержать дубликатов троек.\n\nПримеры:\n[-1,0,1,2,-1,-4] → [[-1,-1,2],[-1,0,1]]\n[] → []\n[0] → []\n[0,0,0] → [[0,0,0]]\n[1,-1,0] → [[-1,0,1]]",
    "hints": {
      "60": "Отсортируйте массив и используйте три указателя",
      "120": "Фиксируйте первый элемент, затем ищите пару для оставшейся суммы"
    },
    "test_code": [
      "def test_three_sum_1(): \n        result = three_sum([-1,0,1,2,-1,-4])\n        assert sorted([sorted(x) for x in result]) == sorted([sorted([-1,-1,2]), sorted([-1,0,1])])",
      "def test_three_sum_2(): assert three_sum([]) == []",
      "def test_three_sum_3(): assert three_sum([0]) == []",
      "def test_three_sum_4(): assert three_sum([0,0,0]) == [[0,0,0]]",
      "def test_three_sum_5(): \n        result = three_sum([1,-1,0])\n        assert sorted([sorted(x) for x in result]) == [sorted([-1,0,1])]",
      "def test_three_sum_6(): \n        result = three_sum([-2,0,1,1,2])\n        expected = [[-2,0,2],[-2,1,1]]\n        assert sorted([sorted(x) for x in result]) == sorted([sorted(x) for x in expected])",
      "def test_three_sum_7(): assert three_sum([1,2,-2,-1]) == []",
      "def test_three_sum_8(): \n        result = three_sum([-1,0,1,0])\n        assert sorted([sorted(x) for x in result]) == [sorted([-1,0,1])]",
      "def test_three_sum_9(): \n        result = three_sum([3,0,-2,-1,1,2])\n        expected = [[-2,-1,3],[-2,0,2],[-1,0,1]]\n        assert sorted([sorted(x) for x in result]) == sorted([sorted(x) for x in expected])",
      "def test_three_sum_10(): assert three_sum([1,1,-2]) == [[-2,1,1]]"
    ]
  },
  {
    "num": "3.14",
    "name": "Следующая перестановка (Google)",
    "code": "def next_permutation(nums: list) -> None:\n    \"\"\"\n    Преобразует nums в следующую лексикографическую перестановку.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "hard",
    "task_text": "Напишите функцию next_permutation(nums: list) -> None, которая преобразует nums в следующую лексикографическую перестановку.\n\nЕсли перестановка является последней, преобразует в первую (отсортированную по возрастанию).\nИзменения производятся на месте.\n\nПримеры:\n[1,2,3] → [1,3,2]\n[3,2,1] → [1,2,3]\n[1,1,5] → [1,5,1]\n[1] → [1]\n[1,3,2] → [2,1,3]",
    "hints": {
      "60": "Найдите первый убывающий элемент справа",
      "120": "Найдите элемент для обмена и переверните правую часть"
    },
    "test_code": [
      "def test_next_perm_1():\n        nums = [1,2,3]\n        next_permutation(nums)\n        assert nums == [1,3,2]",
      "def test_next_perm_2():\n        nums = [3,2,1]\n        next_permutation(nums)\n        assert nums == [1,2,3]",
      "def test_next_perm_3():\n        nums = [1,1,5]\n        next_permutation(nums)\n        assert nums == [1,5,1]",
      "def test_next_perm_4():\n        nums = [1]\n        next_permutation(nums)\n        assert nums == [1]",
      "def test_next_perm_5():\n        nums = [1,3,2]\n        next_permutation(nums)\n        assert nums == [2,1,3]",
      "def test_next_perm_6():\n        nums = [1,2]\n        next_permutation(nums)\n        assert nums == [2,1]",
      "def test_next_perm_7():\n        nums = [5,1,1]\n        next_permutation(nums)\n        assert nums == [1,1,5]",
      "def test_next_perm_8():\n        nums = [1,5,8,4,7,6,5,3,1]\n        next_permutation(nums)\n        assert nums == [1,5,8,5,1,3,4,6,7]",
      "def test_next_perm_9():\n        nums = [2,3,1]\n        next_permutation(nums)\n        assert nums == [3,1,2]",
      "def test_next_perm_10():\n        nums = [1,2,3,4]\n        next_permutation(nums)\n        assert nums == [1,2,4,3]"
    ]
  },
  {
    "num": "3.15",
    "name": "Поиск в повернутом массиве (Google)",
    "code": "def search_rotated_array(nums: list, target: int) -> int:\n    \"\"\"\n    Находит индекс target в повернутом отсортированном массиве.\n    \"\"\"\n    pass",
    "exclude": ["import"],
    "level": "hard",
    "task_text": "Напишите функцию search_rotated_array(nums: list, target: int) -> int, которая находит индекс target в массиве, отсортированном по возрастанию и повернутом в произвольной точке.\n\nЕсли target не найден, верните -1.\n\nПримеры:\n[4,5,6,7,0,1,2], target=0 → 4\n[4,5,6,7,0,1,2], target=3 → -1\n[1], target=0 → -1\n[1], target=1 → 0\n[5,1,3], target=3 → 2",
    "hints": {
      "60": "Используйте модифицированный бинарный поиск",
      "120": "Определите, в какой половине находится target: левой отсортированной или правой"
    },
    "test_code": [
      "def test_search_rot_1(): assert search_rotated_array([4,5,6,7,0,1,2], 0) == 4",
      "def test_search_rot_2(): assert search_rotated_array([4,5,6,7,0,1,2], 3) == -1",
      "def test_search_rot_3(): assert search_rotated_array([1], 0) == -1",
      "def test_search_rot_4(): assert search_rotated_array([1], 1) == 0",
      "def test_search_rot_5(): assert search_rotated_array([5,1,3], 3) == 2",
      "def test_search_rot_6(): assert search_rotated_array([4,5,6,7,0,1,2], 4) == 0",
      "def test_search_rot_7(): assert search_rotated_array([4,5,6,7,0,1,2], 2) == 6",
      "def test_search_rot_8(): assert search_rotated_array([3,1], 1) == 1",
      "def test_search_rot_9(): assert search_rotated_array([3,1], 3) == 0",
      "def test_search_rot_10(): assert search_rotated_array([7,8,1,2,3,4,5,6], 2) == 3"
    ]
  },
  {
    "num": "6.1",
    "name": "Оптимальный маршрут Деда Мороза",
    "code": "def santa_optimal_route(cities: list, distances: list) -> int:\n    \"\"\"\n    Минимальное расстояние для посещения всех городов.\n    \"\"\"\n    pass",
    "exclude": ["import", "math"],
    "level": "hard",
    "task_text": "Напишите функцию santa_optimal_route(cities: list, distances: list) -> int, которая находит минимальное расстояние, которое должен проехать Дед Мороз, чтобы посетить все города и вернуться в начальный.\n\ncities - список городов (от 0 до n-1). distances - матрица расстояний n×n.\n\nПримеры:\n3 городов, расстояния [[0,1,2],[1,0,3],[2,3,0]] → 6 (0→1→2→0)\n4 городов, расстояния [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]] → 80\n1 город → 0\n2 города → удвоенное расстояние между ними",
    "hints": {
      "60": "Это задача коммивояжера (TSP)",
      "120": "Используйте динамическое программирование с маской посещенных городов"
    },
    "test_code": [
      "def test_route_1(): assert santa_optimal_route([0,1,2], [[0,1,2],[1,0,3],[2,3,0]]) == 6",
      "def test_route_2(): assert santa_optimal_route([0,1,2,3], [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]]) == 80",
      "def test_route_3(): assert santa_optimal_route([0], [[0]]) == 0",
      "def test_route_4(): assert santa_optimal_route([0,1], [[0,5],[5,0]]) == 10",
      "def test_route_5(): assert santa_optimal_route([0,1,2], [[0,1,100],[1,0,100],[100,100,0]]) == 202",
      "def test_route_6(): assert santa_optimal_route([0,1,2,3], [[0,1,2,3],[1,0,4,5],[2,4,0,6],[3,5,6,0]]) == 16",
      "def test_route_7(): assert santa_optimal_route([0,1,2,3,4], [[0,2,9,10],[2,0,6,4],[9,6,0,8],[10,4,8,0],[1,3,5,7,0]]) == 21",
      "def test_route_8(): assert santa_optimal_route([0,1,2], [[0,10,15],[10,0,20],[15,20,0]]) == 45",
      "def test_route_9(): assert santa_optimal_route([0,1,2,3,4], [[0,1,1,1,1],[1,0,1,1,1],[1,1,0,1,1],[1,1,1,0,1],[1,1,1,1,0]]) == 5",
      "def test_route_10(): assert santa_optimal_route([0,1,2,3], [[0,3,6,7],[3,0,8,2],[6,8,0,5],[7,2,5,0]]) == 18"
    ]
  },
  {
    "num": "6.2",
    "name": "Распределение подарков",
    "code": "def gift_distribution(children: dict, gifts: dict) -> dict:\n    \"\"\"\n    Распределяет подарки детям по их предпочтениям.\n    \"\"\"\n    pass",
    "exclude": [],
    "level": "middle",
    "task_text": "Напишите функцию gift_distribution(children: dict, gifts: dict) -> dict, которая распределяет подарки детям.\n\nАргументы:\n- children: словарь, где ключ - имя ребенка (str), значение - список желаемых подарков (list[str]).\n- gifts: словарь доступных подарков, где ключ - тип подарка (str), значение - количество (int).\n\nФункция должна вернуть словарь, где ключ - имя ребенка, значение - список подарков, которые он получит.\nПравила:\n1. Ребенок получает только подарки из своего списка желаний.\n2. Каждый подарок можно дать только один раз (учитывается количество в gifts).\n3. Ребенок получает максимум 1 экземпляр каждого типа подарка.\n4. Распределение происходит в порядке перебора детей.\n\nПример:\nchildren = {'Аня': ['кукла', 'мяч'], 'Боря': ['машина', 'мяч']}\ngifts = {'кукла': 2, 'мяч': 1, 'машина': 1}\nРезультат: {'Аня': ['кукла', 'мяч'], 'Боря': ['машина']}",
    "hints": {
      "45": "Создайте копию словаря gifts, чтобы уменьшать количество доступных подарков.",
      "90": "Для каждого ребенка проверяйте каждый подарок из его списка желаний."
    },
    "test_code": [
      "def test_distribution_1(): \n    children = {'Аня': ['кукла', 'мяч'], 'Боря': ['машина', 'мяч']}\n    gifts = {'кукла': 2, 'мяч': 1, 'машина': 1}\n    assert gift_distribution(children, gifts) == {'Аня': ['кукла', 'мяч'], 'Боря': ['машина']}",
      "def test_distribution_2():\n    children = {'Вова': ['конструктор'], 'Петя': ['конструктор', 'робот']}\n    gifts = {'конструктор': 1, 'робот': 0}\n    assert gift_distribution(children, gifts) == {'Вова': ['конструктор'], 'Петя': []}",
      "def test_distribution_3():\n    children = {}\n    gifts = {'книга': 5}\n    assert gift_distribution(children, gifts) == {}",
      "def test_distribution_4():\n    children = {'Маша': ['медведь'], 'Даша': ['заяц']}\n    gifts = {'медведь': 1, 'заяц': 1, 'слон': 1}\n    assert gift_distribution(children, gifts) == {'Маша': ['медведь'], 'Даша': ['заяц']}",
      "def test_distribution_5():\n    children = {'Оля': ['а', 'б', 'в'], 'Коля': ['б', 'г']}\n    gifts = {'а': 1, 'б': 1, 'в': 1, 'г': 1}\n    assert gift_distribution(children, gifts) == {'Оля': ['а', 'б', 'в'], 'Коля': ['г']}"
    ]
  },
  {
    "num": "6.3",
    "name": "Оптимизация загрузки саней",
    "code": "def optimize_sleigh_load(gifts: list, weight_limit: int) -> list:\n    \"\"\"\n    Выбирает максимальное количество подарков, не превышая лимит веса.\n    \"\"\"\n    pass",
    "exclude": [],
    "level": "middle",
    "task_text": "Напишите функцию optimize_sleigh_load(gifts: list, weight_limit: int) -> list, которая выбирает подарки для загрузки в сани.\n\nАргументы:\n- gifts: список словарей, каждый словарь имеет ключи 'name' (str) и 'weight' (int).\n- weight_limit: максимальный общий вес (int).\n\nФункция должна вернуть список имен подарков, которые будут загружены.\nПравила:\n1. Нельзя превысить weight_limit.\n2. Нужно взять максимальное количество подарков (не максимальный вес, а количество!).\n3. Если есть несколько вариантов с одинаковым количеством, выбрать любой.\n4. Подарки рассматриваются в том порядке, в котором они пришли в списке.\n\nПример:\ngifts = [\n    {'name': 'кукла', 'weight': 3},\n    {'name': 'машина', 'weight': 5},\n    {'name': 'книга', 'weight': 2},\n    {'name': 'мяч', 'weight': 4}\n]\nweight_limit = 8\nРезультат: ['кукла', 'книга', 'мяч'] (суммарный вес 3+2+4=9 >8 - не подходит) или ['кукла', 'машина'] (вес 8) - правильный ответ",
    "hints": {
      "60": "Сначала отсортируйте подарки по весу (от легкого к тяжелому).",
      "120": "Идите по отсортированному списку и добавляйте подарки, пока не превысите лимит."
    },
    "test_code": [
      "def test_optimize_1():\n    gifts = [\n        {'name': 'a', 'weight': 3},\n        {'name': 'b', 'weight': 5},\n        {'name': 'c', 'weight': 2},\n        {'name': 'd', 'weight': 4}\n    ]\n    result = optimize_sleigh_load(gifts, 8)\n    assert len(result) == 2\n    total_weight = sum(g['weight'] for g in gifts if g['name'] in result)\n    assert total_weight <= 8",
      "def test_optimize_2():\n    gifts = [\n        {'name': 'маленький', 'weight': 1},\n        {'name': 'средний', 'weight': 3},\n        {'name': 'большой', 'weight': 10}\n    ]\n    result = optimize_sleigh_load(gifts, 5)\n    assert result == ['маленький', 'средний'] or result == ['средний', 'маленький']",
      "def test_optimize_3():\n    gifts = [\n        {'name': 'подарок1', 'weight': 10},\n        {'name': 'подарок2', 'weight': 20}\n    ]\n    assert optimize_sleigh_load(gifts, 5) == []",
      "def test_optimize_4():\n    gifts = [{'name': 'единственный', 'weight': 7}]\n    assert optimize_sleigh_load(gifts, 10) == ['единственный']",
      "def test_optimize_5():\n    gifts = [\n        {'name': 'x', 'weight': 2},\n        {'name': 'y', 'weight': 2},\n        {'name': 'z', 'weight': 2},\n        {'name': 'w', 'weight': 5}\n    ]\n    result = optimize_sleigh_load(gifts, 6)\n    assert len(result) == 3\n    total_weight = sum(g['weight'] for g in gifts if g['name'] in result)\n    assert total_weight == 6"
    ]
  },
  {
    "num": "6.4",
    "name": "Группировка писем от детей",
    "code": "def group_children_letters(letters: list) -> dict:\n    \"\"\"\n    Группирует письма по городам и возрасту детей.\n    \"\"\"\n    pass",
    "exclude": [],
    "level": "middle",
    "task_text": "Напишите функцию group_children_letters(letters: list) -> dict, которая анализирует письма от детей и группирует их.\n\nАргументы:\n- letters: список словарей, каждый словарь представляет письмо и имеет ключи:\n  'child_name' (str), 'city' (str), 'age' (int), 'gift_wish' (str).\n\nФункция должна вернуть словарь с такой структурой:\n{\n    'город1': {\n        'age_groups': {\n            'до 7 лет': [список_имен],\n            '7-12 лет': [список_имен],\n            'старше 12': [список_имён]\n        },\n        'popular_gifts': [список_популярных_подарков]\n    },\n    ...\n}\nПравила группировки по возрасту:\n- 'до 7 лет': age < 7\n- '7-12 лет': 7 ≤ age ≤ 12\n- 'старше 12': age > 12\n\nПопулярные подарки: топ-2 самых частых подарка в этом городе (если подарков меньше 2, то все).\nЕсли у нескольких подарков одинаковая частота, включить все с максимальной частотой.\n\nПример:\nletters = [\n    {'child_name': 'Аня', 'city': 'Москва', 'age': 6, 'gift_wish': 'кукла'},\n    {'child_name': 'Боря', 'city': 'Москва', 'age': 8, 'gift_wish': 'машина'},\n    {'child_name': 'Вова', 'city': 'Москва', 'age': 8, 'gift_wish': 'машина'},\n    {'child_name': 'Даша', 'city': 'СПб', 'age': 10, 'gift_wish': 'книга'}\n]\nЧастичный результат: для Москвы popular_gifts = ['машина', 'кукла']",
    "hints": {
      "60": "Создайте промежуточный словарь для сбора данных по городам.",
      "120": "Для нахождения популярных подарков используйте словарь-счетчик."
    },
    "test_code": [
      "def test_group_1():\n    letters = [\n        {'child_name': 'Аня', 'city': 'Москва', 'age': 6, 'gift_wish': 'кукла'},\n        {'child_name': 'Боря', 'city': 'Москва', 'age': 8, 'gift_wish': 'машина'},\n        {'child_name': 'Вова', 'city': 'Москва', 'age': 8, 'gift_wish': 'машина'}\n    ]\n    result = group_children_letters(letters)\n    assert 'Москва' in result\n    assert result['Москва']['age_groups']['до 7 лет'] == ['Аня']\n    assert set(result['Москва']['age_groups']['7-12 лет']) == {'Боря', 'Вова'}",
      "def test_group_2():\n    letters = [\n        {'child_name': 'А', 'city': 'X', 'age': 5, 'gift_wish': 'яблоко'},\n        {'child_name': 'Б', 'city': 'X', 'age': 5, 'gift_wish': 'яблоко'},\n        {'child_name': 'В', 'city': 'X', 'age': 5, 'gift_wish': 'груша'},\n        {'child_name': 'Г', 'city': 'X', 'age': 5, 'gift_wish': 'слива'}\n    ]\n    result = group_children_letters(letters)\n    gifts = result['X']['popular_gifts']\n    assert 'яблоко' in gifts\n    assert len(gifts) >= 2",
      "def test_group_3():\n    letters = []\n    assert group_children_letters(letters) == {}",
      "def test_group_4():\n    letters = [\n        {'child_name': 'Д', 'city': 'Город', 'age': 15, 'gift_wish': 'телефон'},\n        {'child_name': 'Е', 'city': 'Город', 'age': 3, 'gift_wish': 'мяч'}\n    ]\n    result = group_children_letters(letters)\n    assert result['Город']['age_groups']['старше 12'] == ['Д']\n    assert result['Город']['age_groups']['до 7 лет'] == ['Е']"
    ]
  },
  {
    "num": "6.5",
    "name": "Поиск ближайших остановок оленей",
    "code": "def find_reindeer_stops(houses: list, max_distance: int) -> list:\n    \"\"\"\n    Находит минимальное количество остановок для посещения всех домов.\n    \"\"\"\n    pass",
    "exclude": [],
    "level": "hard",
    "task_text": "Напишите функцию find_reindeer_stops(houses: list, max_distance: int) -> list, которая решает задачу планирования остановок оленей.\n\nАргументы:\n- houses: список координат домов на прямой (list[int]). Координаты отсортированы по возрастанию.\n- max_distance: максимальное расстояние, которое могут пройти олени без остановки (int).\n\nОлени стартуют в точке 0 и должны посетить все дома, развозя подарки.\nОни могут делать остановки для отдыха в любых точках.\nЗадача: найти минимальное количество остановок и их координаты.\nПравила:\n1. Из любой остановки олени могут доехать до любой точки на расстоянии ≤ max_distance.\n2. Нужно минимизировать количество остановок.\n3. Олени должны посетить каждый дом (остановиться рядом с ним или проехать через него).\n4. Возвращается список координат остановок (в порядке их посещения).\n\nПример:\nhouses = [1, 4, 7, 10, 13]\nmax_distance = 6\nОптимальный маршрут: остановка на 7 (покрывает дома 1,4,7), затем на 13 (покрывает 10,13)\nРезультат: [7, 13]\n\nhouses = [2, 5, 9]\nmax_distance = 10\nРезультат: [9] (из 9 можно доехать до всех домов)",
    "hints": {
      "90": "Используйте жадный алгоритм: ставьте остановку как можно дальше, но так чтобы покрыть очередной дом.",
      "180": "Начинайте с первого непокрытого дома, ищите самую дальнюю точку остановки, которая его покроет."
    },
    "test_code": [
      "def test_stops_1():\n    houses = [1, 4, 7, 10, 13]\n    assert find_reindeer_stops(houses, 6) == [7, 13]",
      "def test_stops_2():\n    houses = [2, 5, 9]\n    assert find_reindeer_stops(houses, 10) == [9]",
      "def test_stops_3():\n    houses = [1, 2, 3, 4, 5]\n    assert find_reindeer_stops(houses, 1) == [1, 2, 3, 4, 5]",
      "def test_stops_4():\n    houses = [10, 20, 30, 40]\n    assert find_reindeer_stops(houses, 15) == [15, 35] or find_reindeer_stops(houses, 15) == [15, 40]",
      "def test_stops_5():\n    houses = []\n    assert find_reindeer_stops(houses, 10) == []",
      "def test_stops_6():\n    houses = [5]\n    assert find_reindeer_stops(houses, 10) == [5]",
      "def test_stops_7():\n    houses = [100, 200, 300, 400]\n    result = find_reindeer_stops(houses, 120)\n    assert len(result) == 2\n    # Проверяем что все дома покрыты\n    covered = set()\n    for stop in result:\n        for house in houses:\n            if abs(house - stop) <= 120:\n                covered.add(house)\n    assert covered == set(houses)"
    ]
  },
  {
    "num": "6.6",
    "name": "Статистика новогодних пожеланий",
    "code": "def analyze_wishes(wishes: list) -> dict:\n    \"\"\"\n    Анализирует список пожеланий и возвращает статистику.\n    \"\"\"\n    pass",
    "exclude": [],
    "level": "middle",
    "task_text": "Напишите функцию analyze_wishes(wishes: list) -> dict, которая анализирует новогодние пожелания детей.\n\nАргументы:\n- wishes: список строк, каждая строка содержит пожелание ребенка.\n\nФункция должна вернуть словарь со следующей статистикой:\n{\n    'total_wishes': общее количество пожеланий,\n    'avg_length': средняя длина пожелания в символах,\n    'most_common_word': самое частое слово (в нижнем регистре, без знаков препинания),\n    'wishes_by_length': словарь, где ключ - длина пожелания, значение - количество пожеланий такой длины\n}\n\nПравила обработки текста:\n1. Знаки препинания: . , ! ? : ; \" ' - удаляются\n2. Слова разделяются пробелами\n3. Регистр не имеет значения (приводите к нижнему)\n4. Если есть несколько слов с одинаковой максимальной частотой, верните любое из них\n\nПример:\nwishes = [\n    'Хочу новый велосипед!',\n    'Мир во всем мире.',\n    'Хочу велосипед и мир'\n]\nРезультат:\n{\n    'total_wishes': 3,\n    'avg_length': 18.0,  # (19 + 16 + 19) / 3\n    'most_common_word': 'хочу' или 'велосипед' или 'мир' (встречаются по 2 раза)\n    'wishes_by_length': {19: 2, 16: 1}\n}",
    "hints": {
      "50": "Используйте str.maketrans() или цикл для удаления знаков препинания.",
      "100": "Для подсчета слов создайте словарь-счетчик."
    },
    "test_code": [
      "def test_analyze_1():\n    wishes = ['Хочу велосипед!', 'Мир во всем мире.', 'Хочу велосипед и мир']\n    result = analyze_wishes(wishes)\n    assert result['total_wishes'] == 3\n    assert 17.5 < result['avg_length'] < 20.0\n    assert result['wishes_by_length'][16] == 1",
      "def test_analyze_2():\n    wishes = ['а б в', 'б в г', 'в г д']\n    result = analyze_wishes(wishes)\n    assert result['most_common_word'] == 'в'",
      "def test_analyze_3():\n    wishes = []\n    result = analyze_wishes(wishes)\n    assert result == {'total_wishes': 0, 'avg_length': 0.0, 'most_common_word': '', 'wishes_by_length': {}}",
      "def test_analyze_4():\n    wishes = ['Один!', 'Два?', 'Три.']\n    result = analyze_wishes(wishes)\n    assert result['total_wishes'] == 3\n    assert result['avg_length'] == 4.0\n    assert result['wishes_by_length'][4] == 3",
      "def test_analyze_5():\n    wishes = ['hello world', 'HELLO World', 'hello, world!']\n    result = analyze_wishes(wishes)\n    assert result['most_common_word'] == 'hello' or result['most_common_word'] == 'world'"
    ]
  },
  {
    "num": "7.1",
    "name": "Поиск повторяющихся символов",
    "code": "import re\ndef find_repeated_chars(text: str) -> list:\n    \"\"\"\n    Находит все последовательности одинаковых букв длиной 3 и более.\n    \"\"\"\n    pass",
    "exclude": [],
    "level": "junior",
    "task_text": "Напишите функцию find_repeated_chars(text: str) -> list, которая находит все последовательности одинаковых букв длиной 3 символа и более.\n\nИспользуйте регулярные выражения с квантификаторами.\nВозвращает список найденных последовательностей.\n\nПример:\ntext = 'аааббвввггггд'\nРезультат: ['ааа', 'ввв', 'гггг']\n\nПримечание:\n- Только буквы (латинские и кириллические)\n- Регистр учитывается (А и а - разные буквы)\n- Минимальная длина последовательности: 3 символа",
    "hints": {
      "30": "Используйте квантификатор {3,} для поиска 3 и более повторений.",
      "60": "Шаблон: (буква)\\1{2,} - где \\1 ссылается на найденную букву."
    },
    "test_code": [
      "def test_repeated_1(): \n    assert sorted(find_repeated_chars('аааббвввггггд')) == ['ааа', 'ввв', 'гггг']",
      "def test_repeated_2(): \n    assert find_repeated_chars('abcde') == []",
      "def test_repeated_3(): \n    assert find_repeated_chars('AAAbbbCCC') == ['AAA', 'bbb', 'CCC']",
      "def test_repeated_4(): \n    assert find_repeated_chars('xx yy zzz aaaa b') == ['zzz', 'aaaa']",
      "def test_repeated_5(): \n    assert find_repeated_chars('111 2222 33333') == []  # не буквы"
    ]
  },
  {
    "num": "7.2",
    "name": "Валидация снежинок",
    "code": "import re\ndef validate_snowflake(pattern: str) -> bool:\n    \"\"\"\n    Проверяет, соответствует ли строка шаблону снежинки.\n    \"\"\"\n    pass",
    "exclude": [],
    "level": "middle",
    "task_text": "Напишите функцию validate_snowflake(pattern: str) -> bool, которая проверяет, соответствует ли строка шаблону снежинки.\n\nШаблон снежинки: символ '*' повторяется от 3 до 6 раз подряд.\n\nПримеры валидных снежинок:\n'***', '****', '*****', '******'\n\nПримеры невалидных:\n'**' (мало), '*******' (много), '* *' (пробел), 'abc', ''\n\nИспользуйте регулярные выражения с квантификаторами для проверки.",
    "hints": {
      "40": "Используйте квантификатор {3,6} для точного указания количества.",
      "80": "Убедитесь, что вся строка состоит только из звездочек."
    },
    "test_code": [
      "def test_snowflake_1(): assert validate_snowflake('***') == True",
      "def test_snowflake_2(): assert validate_snowflake('******') == True",
      "def test_snowflake_3(): assert validate_snowflake('**') == False",
      "def test_snowflake_4(): assert validate_snowflake('*******') == False",
      "def test_snowflake_5(): assert validate_snowflake('* *') == False",
      "def test_snowflake_6(): assert validate_snowflake('') == False",
      "def test_snowflake_7(): assert validate_snowflake('****') == True",
      "def test_snowflake_8(): assert validate_snowflake('*****') == True"
    ]
  },
  {
    "num": "7.3",
    "name": "Извлечение новогодних дат",
    "code": "import re\ndef extract_new_year_dates(text: str) -> list:\n    \"\"\"\n    Извлекает даты Нового года из текста.\n    \"\"\"\n    pass",
    "exclude": [],
    "level": "middle",
    "task_text": "Напишите функцию extract_new_year_dates(text: str) -> list, которая извлекает даты Нового года из текста.\n\nФормат даты: '31 декабря' или '1 января'\nДопустимые дни:\n- Для декабря: 31 (только 31)\n- Для января: от 1 до 9 (только однозначные числа)\n\nИспользуйте регулярные выражения с квантификаторами.\nВозвращает список найденных дат в том виде, как они встретились в тексте.\n\nПример:\ntext = 'Празднуем 31 декабря, а 1 января отдыхаем. 10 января уже работаем.'\nРезультат: ['31 декабря', '1 января']\n\nПримечание: '10 января' не должно извлекаться.",
    "hints": {
      "50": "Используйте | для двух вариантов: декабря и января.",
      "100": "Для января используйте диапазон [1-9] (только одна цифра)."
    },
    "test_code": [
      "def test_dates_1(): \n    text = '31 декабря и 1 января'\n    assert extract_new_year_dates(text) == ['31 декабря', '1 января']",
      "def test_dates_2(): \n    text = '30 декабря и 10 января'\n    assert extract_new_year_dates(text) == []",
      "def test_dates_3(): \n    text = '31 декабря, 31 декабря снова'\n    assert extract_new_year_dates(text) == ['31 декабря', '31 декабря']",
      "def test_dates_4(): \n    text = '9 января праздник, 2 января тоже'\n    assert extract_new_year_dates(text) == ['9 января', '2 января']",
      "def test_dates_5(): \n    text = '01 января и 31декабря'\n    assert extract_new_year_dates(text) == []  # нет пробелов или неверный формат",
      "def test_dates_6(): \n    text = ''\n    assert extract_new_year_dates(text) == []"
    ]
  },
  {
    "num": "7.4",
    "name": "Проверка пароля эльфа",
    "code": "import re\ndef validate_elf_password(password: str) -> bool:\n    \"\"\"\n    Проверяет пароль на соответствие правилам эльфов.\n    \"\"\"\n    pass",
    "exclude": [],
    "level": "hard",
    "task_text": "Напишите функцию validate_elf_password(password: str) -> bool, которая проверяет пароль на соответствие правилам эльфов.\n\nПравила пароля:\n1. Длина от 8 до 16 символов\n2. Должен содержать хотя бы 2 заглавные буквы\n3. Должен содержать хотя бы 3 цифры\n4. Должен содержать хотя бы один специальный символ из !@#$%\n5. Может содержать строчные буквы (латинские)\n6. Не должен содержать других символов\n\nИспользуйте регулярные выражения с квантификаторами.\n\nПримеры:\n'AB12!cdef' - невалидный (только 1 заглавная, 2 цифры)\n'ABC123!@#abc' - валидный\n'Ab1!' - невалидный (короткий)\n'ABCD1234!@#$abcd' - невалидный (длинный)",
    "hints": {
      "60": "Используйте положительные lookahead (?=...) для проверки условий.",
      "120": "Каждое условие можно проверить отдельным регулярным выражением."
    },
    "test_code": [
      "def test_password_1(): assert validate_elf_password('ABC123!@#abc') == True",
      "def test_password_2(): assert validate_elf_password('AB12!cdef') == False",
      "def test_password_3(): assert validate_elf_password('Ab1!') == False",
      "def test_password_4(): assert validate_elf_password('ABCD1234!@#$abcd') == False",
      "def test_password_5(): assert validate_elf_password('AB12!cdefgh') == False",
      "def test_password_6(): assert validate_elf_password('ABCDE123!@#xyz') == True",
      "def test_password_7(): assert validate_elf_password('ABC123!@#') == False  # мало строчных не проблема, но длина?",
      "def test_password_8(): assert validate_elf_password('ABcd1234!@') == False  # только 2 заглавные? нужно проверить",
      "def test_password_9(): assert validate_elf_password('') == False",
      "def test_password_10(): assert validate_elf_password('ABC123!@#abcdefg') == True  # ровно 16 символов"
    ]
  },
  {
    "num": "7.5",
    "name": "Поиск номеров подарков",
    "code": "import re\ndef find_gift_numbers(text: str) -> list:\n    \"\"\"\n    Находит номера подарков в тексте.\n    \"\"\"\n    pass",
    "exclude": [],
    "level": "middle",
    "task_text": "Напишите функцию find_gift_numbers(text: str) -> list, которая находит номера подарков в тексте.\n\nФормат номера подарка: 'Подарок №' или 'Подарок N' или 'Gift #' или 'Gift №'\nПосле этого идет номер, который может быть:\n- От 1 до 3 цифр (например: 1, 12, 123)\n- Или римскими цифрами от I до XX (от 1 до 20)\n\nИспользуйте регулярные выражения с квантификаторами.\nВозвращает список найденных номеров (только цифры или римские цифры, без префикса).\n\nПример:\ntext = 'Подарок №5, Gift #XII, Подарок N123, Gift №III'\nРезультат: ['5', 'XII', '123', 'III']\n\nПримечание:\n- Римские цифры: I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, XIII, XIV, XV, XVI, XVII, XVIII, XIX, XX\n- Упрощение: можно считать что римские цифры состоят из символов I, V, X",
    "hints": {
      "40": "Используйте группы (...|...) для вариантов префиксов.",
      "90": "Для римских цифр используйте (?:I[VX]?|V|V?I{0,3}|X[IX]?) - упрощенная проверка."
    },
    "test_code": [
      "def test_gift_1(): \n    text = 'Подарок №5, Gift #XII'\n    assert find_gift_numbers(text) == ['5', 'XII']",
      "def test_gift_2(): \n    text = 'Подарок N999, Gift №1'\n    assert find_gift_numbers(text) == ['1']  # 999 не входит в диапазон 1-3 цифр",
      "def test_gift_3(): \n    text = 'Gift #IV, Подарок №15, Gift №XX'\n    result = find_gift_numbers(text)\n    assert 'IV' in result and '15' in result and 'XX' in result",
      "def test_gift_4(): \n    text = 'Подарок №0, Gift #XXI'\n    assert find_gift_numbers(text) == []  # 0 недопустим, XXI > XX",
      "def test_gift_5(): \n    text = 'Gift # 5, Подарок№10'\n    assert find_gift_numbers(text) == []  # нет пробела или лишний пробел",
      "def test_gift_6(): \n    text = ''\n    assert find_gift_numbers(text) == []"
    ]
  },
  {
    "num": "7.6",
    "name": "Анализ повторяющихся слов",
    "code": "import re\ndef find_repeated_words(text: str) -> dict:\n    \"\"\"\n    Находит слова, которые повторяются подряд 2 или более раз.\n    \"\"\"\n    pass",
    "exclude": [],
    "level": "middle",
    "task_text": "Напишите функцию find_repeated_words(text: str) -> dict, которая находит слова, повторяющиеся подряд 2 или более раза.\n\nВозвращает словарь, где:\n- Ключ: повторяющееся слово (в нижнем регистре)\n- Значение: максимальное количество повторений подряд, найденное в тексте\n\nИспользуйте регулярные выражения с квантификаторами.\n\nПример:\ntext = 'Новый новый Год год год! Привет привет привет всем всем.'\nРезультат: {'новый': 2, 'год': 3, 'привет': 3, 'всем': 2}\n\nПримечание:\n- Слово - последовательность букв (кириллица и латиница)\n- Регистр игнорируется\n- Знаки препинания считаются разделителями\n- 'слово-слово' - это одно слово с дефисом",
    "hints": {
      "50": "Используйте (\\b\\w+\\b)(?:\\s+\\1)+ для поиска повторений.",
      "100": "Игнорируйте регистр с флагом re.IGNORECASE."
    },
    "test_code": [
      "def test_words_1(): \n    text = 'да да нет нет нет может'\n    assert find_repeated_words(text) == {'да': 2, 'нет': 3}",
      "def test_words_2(): \n    text = 'hello hello world world world'\n    assert find_repeated_words(text) == {'hello': 2, 'world': 3}",
      "def test_words_3(): \n    text = 'слово' \n    assert find_repeated_words(text) == {}",
      "def test_words_4(): \n    text = 'Да да ДА да'\n    assert find_repeated_words(text) == {'да': 4}",
      "def test_words_5(): \n    text = 'раз-два раз-два раз-два три три'\n    assert find_repeated_words(text) == {'раз-два': 3, 'три': 2}",
      "def test_words_6(): \n    text = 'a a a b b a a c'\n    assert find_repeated_words(text) == {'a': 3, 'b': 2}"
    ]
  },
  {
    "num": "1",
    "name": "Сумма четных чисел",
    "code": "def sum_even_numbers(n: int) -> int:\n    \"\"\"Вернуть сумму всех четных чисел от 1 до n включительно\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию sum_even_numbers(n), которая принимает целое число n и возвращает сумму всех четных чисел от 1 до n включительно.\nИспользуйте цикл for и range().",
    "test_code": [
      "assert sum_even_numbers(10) == 30",
      "assert sum_even_numbers(1) == 0",
      "assert sum_even_numbers(5) == 6",
      "assert sum_even_numbers(0) == 0"
    ]
  },
  {
    "num": "2",
    "name": "Обратный список",
    "code": "def reverse_list(lst: list) -> list:\n    \"\"\"Вернуть список в обратном порядке без использования reversed()\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию reverse_list(lst), которая возвращает список в обратном порядке.\nНе используйте встроенную функцию reversed() или срез [::-1].",
    "test_code": [
      "assert reverse_list([1, 2, 3]) == [3, 2, 1]",
      "assert reverse_list(['a', 'b', 'c']) == ['c', 'b', 'a']",
      "assert reverse_list([]) == []",
      "assert reverse_list([5]) == [5]"
    ]
  },
  {
    "num": "3",
    "name": "Подсчет слов",
    "code": "def count_words(text: str) -> dict:\n    \"\"\"Посчитать частоту каждого слова в тексте\"\"\"\n    pass",
    "level": "middle",
    "task_text": "Напишите функцию count_words(text), которая принимает строку и возвращает словарь, где ключи - слова, значения - сколько раз они встретились.\nСлова приводить к нижнему регистру, игнорировать знаки препинания . , ! ?",
    "test_code": [
      "assert count_words('hello world hello') == {'hello': 2, 'world': 1}",
      "assert count_words('Hello, world! hello.') == {'hello': 2, 'world': 1}",
      "assert count_words('') == {}",
      "assert count_words('a a a b b') == {'a': 3, 'b': 2}"
    ]
  },
  {
    "num": "4",
    "name": "Генератор квадратов",
    "code": "def squares_generator(n: int):\n    \"\"\"Генератор, который возвращает квадраты чисел от 0 до n-1\"\"\"\n    pass",
    "level": "middle",
    "task_text": "Напишите генератор squares_generator(n), который возвращает квадраты чисел от 0 до n-1.\nИспользуйте yield.",
    "test_code": [
      "assert list(squares_generator(5)) == [0, 1, 4, 9, 16]",
      "assert list(squares_generator(0)) == []",
      "assert list(squares_generator(3)) == [0, 1, 4]"
    ]
  },
  {
    "num": "5",
    "name": "Фильтрация списка",
    "code": "def filter_by_type(lst: list, type_filter) -> list:\n    \"\"\"Отфильтровать список по типу элементов\"\"\"\n    pass",
    "level": "middle",
    "task_text": "Напишите функцию filter_by_type(lst, type_filter), которая возвращает список элементов, имеющих заданный тип.\ntype_filter может быть: int, str, list, dict и т.д.",
    "test_code": [
      "assert filter_by_type([1, 'a', 2, 'b'], int) == [1, 2]",
      "assert filter_by_type([1, [2], 'a', [3]], list) == [[2], [3]]",
      "assert filter_by_type([], str) == []",
      "assert filter_by_type([1, 2, 3], str) == []"
    ]
  },
  {
    "num": "6",
    "name": "Декоратор времени",
    "code": "import time\ndef timer_decorator(func):\n    \"\"\"Декоратор для измерения времени выполнения функции\"\"\"\n    pass",
    "level": "hard",
    "task_text": "Напишите декоратор timer_decorator, который измеряет время выполнения функции и выводит его в секундах.\nДекоратор должен работать с функциями, принимающими любые аргументы.",
    "test_code": [
      "@timer_decorator\ndef test_func():\n    time.sleep(0.1)\n    return 'done'\n\n# Запустить вручную и проверить вывод"
    ]
  },
  {
    "num": "7",
    "name": "Слияние словарей",
    "code": "def merge_dicts(dict1: dict, dict2: dict) -> dict:\n    \"\"\"Объединить два словаря, при конфликте берутся значения из dict2\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию merge_dicts(dict1, dict2), которая объединяет два словаря.\nЕсли ключ есть в обоих словарях, берётся значение из dict2.",
    "test_code": [
      "assert merge_dicts({'a': 1}, {'b': 2}) == {'a': 1, 'b': 2}",
      "assert merge_dicts({'a': 1}, {'a': 2, 'b': 3}) == {'a': 2, 'b': 3}",
      "assert merge_dicts({}, {'x': 10}) == {'x': 10}",
      "assert merge_dicts({}, {}) == {}"
    ]
  },
  {
    "num": "8",
    "name": "Список уникальных элементов",
    "code": "def unique_elements(lst: list) -> list:\n    \"\"\"Вернуть список уникальных элементов в порядке первого вхождения\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию unique_elements(lst), которая возвращает список уникальных элементов в порядке их первого вхождения.\nНе используйте set() или готовые функции для удаления дубликатов.",
    "test_code": [
      "assert unique_elements([1, 2, 2, 3, 1]) == [1, 2, 3]",
      "assert unique_elements(['a', 'b', 'a', 'c']) == ['a', 'b', 'c']",
      "assert unique_elements([]) == []",
      "assert unique_elements([1, 1, 1]) == [1]"
    ]
  },
  {
    "num": "9",
    "name": "Генератор Фибоначчи",
    "code": "def fibonacci_generator(n: int):\n    \"\"\"Генератор первых n чисел Фибоначчи\"\"\"\n    pass",
    "level": "middle",
    "task_text": "Напишите генератор fibonacci_generator(n), который возвращает первые n чисел последовательности Фибоначчи.\nФибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, ...",
    "test_code": [
      "assert list(fibonacci_generator(5)) == [0, 1, 1, 2, 3]",
      "assert list(fibonacci_generator(1)) == [0]",
      "assert list(fibonacci_generator(0)) == []",
      "assert list(fibonacci_generator(7)) == [0, 1, 1, 2, 3, 5, 8]"
    ]
  },
  {
    "num": "10",
    "name": "Декоратор кэширования",
    "code": "def cache_decorator(func):\n    \"\"\"Декоратор для кэширования результатов функции\"\"\"\n    pass",
    "level": "hard",
    "task_text": "Напишите декоратор cache_decorator, который кэширует результаты вызова функции.\nПри повторном вызове с теми же аргументами возвращать результат из кэша, не вычисляя заново.",
    "test_code": [
      "call_count = 0\n@cache_decorator\ndef expensive_func(x):\n    nonlocal call_count\n    call_count += 1\n    return x * 2\n\n# Первый вызов\nassert expensive_func(5) == 10\n# Второй вызов с теми же аргументами - должен взять из кэша\nassert expensive_func(5) == 10\n# Проверить что функция вызвалась только 1 раз"
    ]
  },
  {
    "num": "11",
    "name": "Транспонирование матрицы",
    "code": "def transpose_matrix(matrix: list) -> list:\n    \"\"\"Транспонировать матрицу (список списков)\"\"\"\n    pass",
    "level": "middle",
    "task_text": "Напишите функцию transpose_matrix(matrix), которая транспонирует матрицу (список списков).\nПредполагается, что все строки матрицы имеют одинаковую длину.",
    "test_code": [
      "assert transpose_matrix([[1, 2], [3, 4]]) == [[1, 3], [2, 4]]",
      "assert transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]]",
      "assert transpose_matrix([[]]) == [[]]",
      "assert transpose_matrix([[1]]) == [[1]]"
    ]
  },
  {
    "num": "12",
    "name": "Глубокое слияние словарей",
    "code": "def deep_merge(dict1: dict, dict2: dict) -> dict:\n    \"\"\"Рекурсивное глубокое слияние словарей\"\"\"\n    pass",
    "level": "hard",
    "task_text": "Напишите функцию deep_merge(dict1, dict2), которая рекурсивно сливает два словаря.\nЕсли значения - словари, сливать их рекурсивно, иначе брать значение из dict2.",
    "test_code": [
      "d1 = {'a': {'x': 1}, 'b': 2}\nd2 = {'a': {'y': 3}, 'c': 4}\nresult = deep_merge(d1, d2)\nassert result == {'a': {'x': 1, 'y': 3}, 'b': 2, 'c': 4}",
      "assert deep_merge({}, {}) == {}",
      "assert deep_merge({'x': 1}, {'x': 2}) == {'x': 2}"
    ]
  },
  {
    "num": "13",
    "name": "Генератор простых чисел",
    "code": "def primes_generator(limit: int):\n    \"\"\"Генератор простых чисел до limit\"\"\"\n    pass",
    "level": "hard",
    "task_text": "Напишите генератор primes_generator(limit), который возвращает все простые числа до limit включительно.",
    "test_code": [
      "assert list(primes_generator(10)) == [2, 3, 5, 7]",
      "assert list(primes_generator(2)) == [2]",
      "assert list(primes_generator(1)) == []",
      "assert list(primes_generator(20)) == [2, 3, 5, 7, 11, 13, 17, 19]"
    ]
  },
  {
    "num": "14",
    "name": "Декоратор валидации аргументов",
    "code": "def validate_args(arg_types: list):\n    \"\"\"Декоратор для проверки типов аргументов\"\"\"\n    pass",
    "level": "hard",
    "task_text": "Напишите декоратор validate_args, который принимает список типов и проверяет,\nчто аргументы функции соответствуют этим типам. Если нет - бросать TypeError.",
    "test_code": [
      "@validate_args([int, str])\ndef func(x, y):\n    return f'{x}{y}'\n\nassert func(5, 'hello') == '5hello'\n# При вызове func(5, 10) должно возникнуть TypeError"
    ]
  },
  {
    "num": "15",
    "name": "Группировка по ключу",
    "code": "def group_by(lst: list, key_func) -> dict:\n    \"\"\"Группировать элементы списка по ключу\"\"\"\n    pass",
    "level": "middle",
    "task_text": "Напишите функцию group_by(lst, key_func), которая группирует элементы списка по ключу.\nkey_func - функция, которая принимает элемент и возвращает ключ для группировки.",
    "test_code": [
      "assert group_by([1, 2, 3, 4], lambda x: x % 2) == {0: [2, 4], 1: [1, 3]}",
      "words = ['apple', 'banana', 'cherry', 'date']\nassert group_by(words, len) == {5: ['apple'], 6: ['banana', 'cherry'], 4: ['date']}",
      "assert group_by([], lambda x: x) == {}"
    ]
  },
  {
    "num": "16",
    "name": "Чередование списков",
    "code": "def interleave_lists(list1: list, list2: list) -> list:\n    \"\"\"Чередовать элементы двух списков\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию interleave_lists(list1, list2), которая чередует элементы двух списков.\nЕсли списки разной длины, оставшиеся элементы добавить в конец.",
    "test_code": [
      "assert interleave_lists([1, 2, 3], ['a', 'b', 'c']) == [1, 'a', 2, 'b', 3, 'c']",
      "assert interleave_lists([1, 2], ['a', 'b', 'c', 'd']) == [1, 'a', 2, 'b', 'c', 'd']",
      "assert interleave_lists([], [1, 2]) == [1, 2]",
      "assert interleave_lists([1, 2], []) == [1, 2]"
    ]
  },
  {
    "num": "17",
    "name": "Генератор скользящего окна",
    "code": "def sliding_window(lst: list, size: int):\n    \"\"\"Генератор скользящего окна по списку\"\"\"\n    pass",
    "level": "middle",
    "task_text": "Напишите генератор sliding_window(lst, size), который возвращает последовательные подсписки заданного размера.\nЕсли size больше длины списка, не возвращать ничего.",
    "test_code": [
      "assert list(sliding_window([1, 2, 3, 4, 5], 3)) == [[1, 2, 3], [2, 3, 4], [3, 4, 5]]",
      "assert list(sliding_window([1, 2, 3], 5)) == []",
      "assert list(sliding_window([1, 2, 3], 1)) == [[1], [2], [3]]",
      "assert list(sliding_window([], 2)) == []"
    ]
  },
  {
    "num": "18",
    "name": "Декоратор повторных попыток",
    "code": "def retry_decorator(max_attempts: int):\n    \"\"\"Декоратор для повторных попыток выполнения функции\"\"\"\n    pass",
    "level": "hard",
    "task_text": "Напишите декоратор retry_decorator, который принимает максимальное количество попыток.\nПри возникновении исключения в функции, повторить вызов до max_attempts раз.",
    "test_code": [
      "attempts = 0\n@retry_decorator(3)\ndef unstable_func():\n    nonlocal attempts\n    attempts += 1\n    if attempts < 3:\n        raise ValueError('Error')\n    return 'success'\n\nassert unstable_func() == 'success'\nassert attempts == 3"
    ]
  },
  {
    "num": "19",
    "name": "Словарь инвертированный",
    "code": "def invert_dict(d: dict) -> dict:\n    \"\"\"Инвертировать словарь (ключи ↔ значения)\"\"\"\n    pass",
    "level": "middle",
    "task_text": "Напишите функцию invert_dict(d), которая инвертирует словарь (меняет местами ключи и значения).\nЕсли в исходном словаре есть повторяющиеся значения, в новом словаре значения должны быть списками.",
    "test_code": [
      "assert invert_dict({'a': 1, 'b': 2}) == {1: 'a', 2: 'b'}",
      "assert invert_dict({'a': 1, 'b': 1, 'c': 2}) == {1: ['a', 'b'], 2: 'c'}",
      "assert invert_dict({}) == {}",
      "assert invert_dict({'x': 'y'}) == {'y': 'x'}"
    ]
  },
  {
    "num": "20",
    "name": "Генератор бегущей суммы",
    "code": "def running_sum_generator(lst: list):\n    \"\"\"Генератор бегущей (кумулятивной) суммы\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите генератор running_sum_generator(lst), который возвращает бегущую сумму элементов списка.\nНапример, для [1, 2, 3, 4] -> [1, 3, 6, 10].",
    "test_code": [
      "assert list(running_sum_generator([1, 2, 3, 4])) == [1, 3, 6, 10]",
      "assert list(running_sum_generator([])) == []",
      "assert list(running_sum_generator([5])) == [5]",
      "assert list(running_sum_generator([-1, 1, -1, 1])) == [-1, 0, -1, 0]"
    ]
  },
  {
    "num": "1.1",
    "name": "Сумма элементов списка",
    "code": "def sum_list(numbers: list) -> int:\n    \"\"\"Вернуть сумму всех чисел в списке\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию sum_list(numbers), которая принимает список чисел и возвращает их сумму.\nИспользуйте цикл for.\nПример: sum_list([1, 2, 3]) → 6",
    "test_code": [
      "assert sum_list([1, 2, 3]) == 6",
      "assert sum_list([]) == 0",
      "assert sum_list([-5, 10, 3]) == 8",
      "assert sum_list([5]) == 5"
    ]
  },
  {
    "num": "1.2",
    "name": "Максимальный элемент",
    "code": "def find_max(numbers: list) -> int:\n    \"\"\"Найти максимальное число в списке\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию find_max(numbers), которая находит максимальное число в списке.\nНе используйте встроенные функции max().\nПример: find_max([3, 1, 4, 2]) → 4",
    "test_code": [
      "assert find_max([3, 1, 4, 2]) == 4",
      "assert find_max([-10, -5, -1]) == -1",
      "assert find_max([7]) == 7",
      "assert find_max([5, 5, 5]) == 5"
    ]
  },
  {
    "num": "1.3",
    "name": "Подсчет положительных чисел",
    "code": "def count_positive(numbers: list) -> int:\n    \"\"\"Посчитать количество положительных чисел\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию count_positive(numbers), которая подсчитывает количество положительных чисел в списке.\nПример: count_positive([-1, 2, -3, 4]) → 2",
    "test_code": [
      "assert count_positive([-1, 2, -3, 4]) == 2",
      "assert count_positive([1, 2, 3]) == 3",
      "assert count_positive([-1, -2, -3]) == 0",
      "assert count_positive([]) == 0"
    ]
  },
  {
    "num": "1.4",
    "name": "Удвоение элементов",
    "code": "def double_list(numbers: list) -> list:\n    \"\"\"Вернуть новый список с удвоенными значениями\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию double_list(numbers), которая возвращает новый список, где каждый элемент умножен на 2.\nНе изменяйте исходный список.\nПример: double_list([1, 2, 3]) → [2, 4, 6]",
    "test_code": [
      "assert double_list([1, 2, 3]) == [2, 4, 6]",
      "assert double_list([]) == []",
      "assert double_list([0]) == [0]",
      "assert double_list([-3, 5]) == [-6, 10]"
    ]
  },
  {
    "num": "1.5",
    "name": "Поиск элемента",
    "code": "def find_element(lst: list, element) -> bool:\n    \"\"\"Проверить, есть ли элемент в списке\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию find_element(lst, element), которая проверяет, есть ли элемент в списке.\nНе используйте оператор in.\nПример: find_element([1, 2, 3], 2) → True",
    "test_code": [
      "assert find_element([1, 2, 3], 2) == True",
      "assert find_element(['a', 'b', 'c'], 'd') == False",
      "assert find_element([], 5) == False",
      "assert find_element([1, 1, 1], 1) == True"
    ]
  },
  {
    "num": "1.6",
    "name": "Объединение списков",
    "code": "def concat_lists(list1: list, list2: list) -> list:\n    \"\"\"Объединить два списка в один\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию concat_lists(list1, list2), которая объединяет два списка в один.\nНе используйте оператор + или метод extend().\nПример: concat_lists([1, 2], [3, 4]) → [1, 2, 3, 4]",
    "test_code": [
      "assert concat_lists([1, 2], [3, 4]) == [1, 2, 3, 4]",
      "assert concat_lists([], [1, 2]) == [1, 2]",
      "assert concat_lists(['a'], ['b']) == ['a', 'b']",
      "assert concat_lists([], []) == []"
    ]
  },
  {
    "num": "1.7",
    "name": "Удаление дубликатов",
    "code": "def remove_duplicates(lst: list) -> list:\n    \"\"\"Удалить повторяющиеся элементы из списка\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию remove_duplicates(lst), которая удаляет повторяющиеся элементы из списка, сохраняя порядок.\nНе используйте множества (set).\nПример: remove_duplicates([1, 2, 2, 3, 1]) → [1, 2, 3]",
    "test_code": [
      "assert remove_duplicates([1, 2, 2, 3, 1]) == [1, 2, 3]",
      "assert remove_duplicates(['a', 'b', 'a']) == ['a', 'b']",
      "assert remove_duplicates([]) == []",
      "assert remove_duplicates([1, 1, 1]) == [1]"
    ]
  },
  {
    "num": "1.8",
    "name": "Четные индексы",
    "code": "def even_index_elements(lst: list) -> list:\n    \"\"\"Вернуть элементы с четными индексами\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию even_index_elements(lst), которая возвращает список элементов, стоящих на четных индексах.\nИндексация начинается с 0.\nПример: even_index_elements([0, 1, 2, 3, 4]) → [0, 2, 4]",
    "test_code": [
      "assert even_index_elements([0, 1, 2, 3, 4]) == [0, 2, 4]",
      "assert even_index_elements(['a', 'b', 'c', 'd']) == ['a', 'c']",
      "assert even_index_elements([]) == []",
      "assert even_index_elements([5]) == [5]"
    ]
  },
  {
    "num": "1.9",
    "name": "Сумма двух списков",
    "code": "def sum_two_lists(list1: list, list2: list) -> list:\n    \"\"\"Сложить соответствующие элементы двух списков\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию sum_two_lists(list1, list2), которая возвращает новый список, где каждый элемент равен сумме соответствующих элементов входных списков.\nСписки одинаковой длины.\nПример: sum_two_lists([1, 2, 3], [4, 5, 6]) → [5, 7, 9]",
    "test_code": [
      "assert sum_two_lists([1, 2, 3], [4, 5, 6]) == [5, 7, 9]",
      "assert sum_two_lists([0, 0], [1, 2]) == [1, 2]",
      "assert sum_two_lists([-1, 5], [3, -5]) == [2, 0]",
      "assert sum_two_lists([], []) == []"
    ]
  },
  {
    "num": "1.10",
    "name": "Подсчет вхождений",
    "code": "def count_occurrences(lst: list, element) -> int:\n    \"\"\"Посчитать, сколько раз элемент встречается в списке\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию count_occurrences(lst, element), которая подсчитывает, сколько раз элемент встречается в списке.\nПример: count_occurrences([1, 2, 1, 3, 1], 1) → 3",
    "test_code": [
      "assert count_occurrences([1, 2, 1, 3, 1], 1) == 3",
      "assert count_occurrences(['a', 'b', 'c'], 'd') == 0",
      "assert count_occurrences([], 5) == 0",
      "assert count_occurrences([7, 7, 7], 7) == 3"
    ]
  },
  {
    "num": "2.1",
    "name": "Создание словаря из списков",
    "code": "def create_dict(keys: list, values: list) -> dict:\n    \"\"\"Создать словарь из двух списков\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию create_dict(keys, values), которая создает словарь из двух списков одинаковой длины.\nПример: create_dict(['a', 'b'], [1, 2]) → {'a': 1, 'b': 2}",
    "test_code": [
      "assert create_dict(['a', 'b'], [1, 2]) == {'a': 1, 'b': 2}",
      "assert create_dict([], []) == {}",
      "assert create_dict(['x'], [10]) == {'x': 10}",
      "assert create_dict(['имя', 'возраст'], ['Аня', 12]) == {'имя': 'Аня', 'возраст': 12}"
    ]
  },
  {
    "num": "2.2",
    "name": "Получение ключей словаря",
    "code": "def get_keys(d: dict) -> list:\n    \"\"\"Получить список всех ключей словаря\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию get_keys(d), которая возвращает список всех ключей словаря.\nПример: get_keys({'a': 1, 'b': 2}) → ['a', 'b']",
    "test_code": [
      "assert sorted(get_keys({'a': 1, 'b': 2})) == ['a', 'b']",
      "assert get_keys({}) == []",
      "assert sorted(get_keys({1: 'a', 2: 'b'})) == [1, 2]"
    ]
  },
  {
    "num": "2.3",
    "name": "Получение значений словаря",
    "code": "def get_values(d: dict) -> list:\n    \"\"\"Получить список всех значений словаря\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию get_values(d), которая возвращает список всех значений словаря.\nПример: get_values({'a': 1, 'b': 2}) → [1, 2]",
    "test_code": [
      "assert sorted(get_values({'a': 1, 'b': 2})) == [1, 2]",
      "assert get_values({}) == []",
      "assert sorted(get_values({'x': 10, 'y': 20, 'z': 10})) == [10, 10, 20]"
    ]
  },
  {
    "num": "2.4",
    "name": "Проверка ключа",
    "code": "def has_key(d: dict, key) -> bool:\n    \"\"\"Проверить, есть ли ключ в словаре\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию has_key(d, key), которая проверяет, есть ли ключ в словаре.\nПример: has_key({'a': 1}, 'a') → True\nhas_key({'a': 1}, 'b') → False",
    "test_code": [
      "assert has_key({'a': 1}, 'a') == True",
      "assert has_key({'a': 1}, 'b') == False",
      "assert has_key({}, 'x') == False",
      "assert has_key({1: 'a'}, 1) == True"
    ]
  },
  {
    "num": "2.5",
    "name": "Слияние словарей",
    "code": "def merge_dicts(dict1: dict, dict2: dict) -> dict:\n    \"\"\"Объединить два словаря\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию merge_dicts(dict1, dict2), которая объединяет два словаря.\nЕсли ключ есть в обоих словарях, использовать значение из dict2.\nПример: merge_dicts({'a': 1}, {'b': 2}) → {'a': 1, 'b': 2}\nmerge_dicts({'a': 1}, {'a': 3}) → {'a': 3}",
    "test_code": [
      "assert merge_dicts({'a': 1}, {'b': 2}) == {'a': 1, 'b': 2}",
      "assert merge_dicts({'a': 1}, {'a': 3}) == {'a': 3}",
      "assert merge_dicts({}, {'x': 5}) == {'x': 5}",
      "assert merge_dicts({'x': 1, 'y': 2}, {'y': 3, 'z': 4}) == {'x': 1, 'y': 3, 'z': 4}"
    ]
  },
  {
    "num": "2.6",
    "name": "Подсчет суммы значений",
    "code": "def sum_dict_values(d: dict) -> int:\n    \"\"\"Вычислить сумму всех значений словаря\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию sum_dict_values(d), которая вычисляет сумму всех значений словаря.\nЗначения должны быть числами.\nПример: sum_dict_values({'a': 10, 'b': 20}) → 30",
    "test_code": [
      "assert sum_dict_values({'a': 10, 'b': 20}) == 30",
      "assert sum_dict_values({}) == 0",
      "assert sum_dict_values({'x': 5}) == 5",
      "assert sum_dict_values({'a': -3, 'b': 7}) == 4"
    ]
  },
  {
    "num": "2.7",
    "name": "Инвертирование словаря",
    "code": "def invert_dict(d: dict) -> dict:\n    \"\"\"Поменять местами ключи и значения\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию invert_dict(d), которая меняет местами ключи и значения словаря.\nПример: invert_dict({'a': 1, 'b': 2}) → {1: 'a', 2: 'b'}",
    "test_code": [
      "assert invert_dict({'a': 1, 'b': 2}) == {1: 'a', 2: 'b'}",
      "assert invert_dict({}) == {}",
      "assert invert_dict({'x': 'y'}) == {'y': 'x'}",
      "assert invert_dict({1: 'один', 2: 'два'}) == {'один': 1, 'два': 2}"
    ]
  },
  {
    "num": "2.8",
    "name": "Фильтрация по значению",
    "code": "def filter_dict_by_value(d: dict, threshold: int) -> dict:\n    \"\"\"Отфильтровать словарь по значению\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию filter_dict_by_value(d, threshold), которая возвращает новый словарь, содержащий только те пары ключ-значение, где значение больше threshold.\nПример: filter_dict_by_value({'a': 10, 'b': 5, 'c': 15}, 7) → {'a': 10, 'c': 15}",
    "test_code": [
      "assert filter_dict_by_value({'a': 10, 'b': 5, 'c': 15}, 7) == {'a': 10, 'c': 15}",
      "assert filter_dict_by_value({'x': 1}, 5) == {}",
      "assert filter_dict_by_value({}, 10) == {}",
      "assert filter_dict_by_value({'a': 3, 'b': 4, 'c': 5}, 3) == {'c': 5}"
    ]
  },
  {
    "num": "2.9",
    "name": "Подсчет частоты слов",
    "code": "def word_frequency(text: str) -> dict:\n    \"\"\"Посчитать частоту слов в тексте\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию word_frequency(text), которая подсчитывает, сколько раз каждое слово встречается в тексте.\nСлова разделены пробелами, регистр не учитывать.\nПример: word_frequency('hello world hello') → {'hello': 2, 'world': 1}",
    "test_code": [
      "assert word_frequency('hello world hello') == {'hello': 2, 'world': 1}",
      "assert word_frequency('') == {}",
      "assert word_frequency('a a a') == {'a': 3}",
      "assert word_frequency('Hello hello') == {'hello': 2}"
    ]
  },
  {
    "num": "2.10",
    "name": "Максимальное значение",
    "code": "def max_value(d: dict) -> tuple:\n    \"\"\"Найти максимальное значение и соответствующий ключ\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию max_value(d), которая находит максимальное значение в словаре и возвращает кортеж (ключ, значение).\nЕсли словарь пустой, вернуть (None, None).\nПример: max_value({'a': 10, 'b': 5, 'c': 15}) → ('c', 15)",
    "test_code": [
      "assert max_value({'a': 10, 'b': 5, 'c': 15}) == ('c', 15)",
      "assert max_value({}) == (None, None)",
      "assert max_value({'x': 5}) == ('x', 5)",
      "assert max_value({'a': -10, 'b': -5}) == ('b', -5)"
    ]
  },
  {
    "num": "3.1",
    "name": "Создание множества из списка",
    "code": "def list_to_set(lst: list) -> set:\n    \"\"\"Преобразовать список в множество\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию list_to_set(lst), которая преобразует список в множество.\nПример: list_to_set([1, 2, 2, 3, 1]) → {1, 2, 3}",
    "test_code": [
      "assert list_to_set([1, 2, 2, 3, 1]) == {1, 2, 3}",
      "assert list_to_set([]) == set()",
      "assert list_to_set(['a', 'b', 'a']) == {'a', 'b'}",
      "assert list_to_set([1]) == {1}"
    ]
  },
  {
    "num": "3.2",
    "name": "Пересечение множеств",
    "code": "def intersection_set(set1: set, set2: set) -> set:\n    \"\"\"Найти пересечение двух множеств\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию intersection_set(set1, set2), которая находит пересечение двух множеств (элементы, которые есть в обоих множествах).\nНе используйте оператор &.\nПример: intersection_set({1, 2, 3}, {2, 3, 4}) → {2, 3}",
    "test_code": [
      "assert intersection_set({1, 2, 3}, {2, 3, 4}) == {2, 3}",
      "assert intersection_set({1, 2}, {3, 4}) == set()",
      "assert intersection_set(set(), {1, 2}) == set()",
      "assert intersection_set({'a', 'b'}, {'b', 'c'}) == {'b'}"
    ]
  },
  {
    "num": "3.3",
    "name": "Объединение множеств",
    "code": "def union_set(set1: set, set2: set) -> set:\n    \"\"\"Найти объединение двух множеств\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию union_set(set1, set2), которая находит объединение двух множеств (все элементы из обоих множеств).\nНе используйте оператор |.\nПример: union_set({1, 2}, {3, 4}) → {1, 2, 3, 4}",
    "test_code": [
      "assert union_set({1, 2}, {3, 4}) == {1, 2, 3, 4}",
      "assert union_set({1, 2}, {2, 3}) == {1, 2, 3}",
      "assert union_set(set(), {1}) == {1}",
      "assert union_set({'a'}, {'b'}) == {'a', 'b'}"
    ]
  },
  {
    "num": "3.4",
    "name": "Разность множеств",
    "code": "def difference_set(set1: set, set2: set) -> set:\n    \"\"\"Найти разность двух множеств\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию difference_set(set1, set2), которая находит разность множеств (элементы, которые есть в set1, но нет в set2).\nНе используйте оператор -.\nПример: difference_set({1, 2, 3}, {2, 3}) → {1}",
    "test_code": [
      "assert difference_set({1, 2, 3}, {2, 3}) == {1}",
      "assert difference_set({1, 2}, {3, 4}) == {1, 2}",
      "assert difference_set(set(), {1}) == set()",
      "assert difference_set({'a', 'b'}, {'b'}) == {'a'}"
    ]
  },
  {
    "num": "3.5",
    "name": "Симметрическая разность",
    "code": "def symmetric_difference(set1: set, set2: set) -> set:\n    \"\"\"Найти симметрическую разность множеств\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию symmetric_difference(set1, set2), которая находит симметрическую разность множеств (элементы, которые есть только в одном из множеств).\nНе используйте оператор ^.\nПример: symmetric_difference({1, 2, 3}, {2, 3, 4}) → {1, 4}",
    "test_code": [
      "assert symmetric_difference({1, 2, 3}, {2, 3, 4}) == {1, 4}",
      "assert symmetric_difference({1, 2}, {3, 4}) == {1, 2, 3, 4}",
      "assert symmetric_difference(set(), {1}) == {1}",
      "assert symmetric_difference({1, 1}, {1}) == set()"
    ]
  },
  {
    "num": "3.6",
    "name": "Подмножество",
    "code": "def is_subset(set1: set, set2: set) -> bool:\n    \"\"\"Проверить, является ли set1 подмножеством set2\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию is_subset(set1, set2), которая проверяет, является ли set1 подмножеством set2 (все элементы set1 есть в set2).\nПример: is_subset({1, 2}, {1, 2, 3}) → True\nis_subset({1, 4}, {1, 2, 3}) → False",
    "test_code": [
      "assert is_subset({1, 2}, {1, 2, 3}) == True",
      "assert is_subset({1, 4}, {1, 2, 3}) == False",
      "assert is_subset(set(), {1, 2}) == True",
      "assert is_subset(set(), set()) == True"
    ]
  },
  {
    "num": "3.7",
    "name": "Уникальные элементы",
    "code": "def find_unique_elements(lst: list) -> list:\n    \"\"\"Найти элементы, которые встречаются только один раз\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию find_unique_elements(lst), которая находит элементы списка, которые встречаются только один раз.\nПример: find_unique_elements([1, 2, 2, 3, 4, 4, 5]) → [1, 3, 5]",
    "test_code": [
      "assert sorted(find_unique_elements([1, 2, 2, 3, 4, 4, 5])) == [1, 3, 5]",
      "assert find_unique_elements([]) == []",
      "assert find_unique_elements([1, 1, 1]) == []",
      "assert find_unique_elements(['a', 'b', 'a', 'c']) == ['b', 'c']"
    ]
  },
  {
    "num": "3.8",
    "name": "Общие элементы в нескольких списках",
    "code": "def common_elements(lists: list) -> set:\n    \"\"\"Найти общие элементы во всех списках\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию common_elements(lists), которая принимает список списков и возвращает множество элементов, которые есть во всех списках.\nПример: common_elements([[1, 2, 3], [2, 3, 4], [2, 5]]) → {2}",
    "test_code": [
      "assert common_elements([[1, 2, 3], [2, 3, 4], [2, 5]]) == {2}",
      "assert common_elements([[1, 2], [3, 4]]) == set()",
      "assert common_elements([[], [1, 2]]) == set()",
      "assert common_elements([[1, 2, 3], [1, 2, 3]]) == {1, 2, 3}"
    ]
  },
  {
    "num": "3.9",
    "name": "Удаление дубликатов с сохранением порядка",
    "code": "def remove_duplicates_ordered(lst: list) -> list:\n    \"\"\"Удалить дубликаты, сохраняя порядок\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию remove_duplicates_ordered(lst), которая удаляет повторяющиеся элементы из списка, сохраняя порядок их первого появления.\nИспользуйте множества для проверки.\nПример: remove_duplicates_ordered([1, 2, 2, 3, 1]) → [1, 2, 3]",
    "test_code": [
      "assert remove_duplicates_ordered([1, 2, 2, 3, 1]) == [1, 2, 3]",
      "assert remove_duplicates_ordered([]) == []",
      "assert remove_duplicates_ordered(['a', 'b', 'a', 'c']) == ['a', 'b', 'c']",
      "assert remove_duplicates_ordered([1]) == [1]"
    ]
  },
  {
    "num": "3.10",
    "name": "Элементы только в одном множестве",
    "code": "def unique_in_sets(set1: set, set2: set) -> tuple:\n    \"\"\"Найти элементы, которые есть только в одном из множеств\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию unique_in_sets(set1, set2), которая возвращает кортеж из двух множеств:\n1. Элементы, которые есть только в set1\n2. Элементы, которые есть только в set2\nПример: unique_in_sets({1, 2, 3}, {2, 3, 4}) → ({1}, {4})",
    "test_code": [
      "assert unique_in_sets({1, 2, 3}, {2, 3, 4}) == ({1}, {4})",
      "assert unique_in_sets({1, 2}, {3, 4}) == ({1, 2}, {3, 4})",
      "assert unique_in_sets(set(), {1, 2}) == (set(), {1, 2})",
      "assert unique_in_sets({'a'}, {'a'}) == (set(), set())"
    ]
  },
  {
    "num": "4.1",
    "name": "Сумма кортежа",
    "code": "def sum_tuple(t: tuple) -> int:\n    \"\"\"Вычислить сумму элементов кортежа\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию sum_tuple(t), которая вычисляет сумму элементов кортежа.\nПример: sum_tuple((1, 2, 3)) → 6",
    "test_code": [
      "assert sum_tuple((1, 2, 3)) == 6",
      "assert sum_tuple(()) == 0",
      "assert sum_tuple((5,)) == 5",
      "assert sum_tuple((-1, 0, 1)) == 0"
    ]
  },
  {
    "num": "4.2",
    "name": "Преобразование список ↔ кортеж",
    "code": "def convert_list_tuple(lst: list) -> tuple:\n    \"\"\"Преобразовать список в кортеж\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию convert_list_tuple(lst), которая преобразует список в кортеж.\nПример: convert_list_tuple([1, 2, 3]) → (1, 2, 3)",
    "test_code": [
      "assert convert_list_tuple([1, 2, 3]) == (1, 2, 3)",
      "assert convert_list_tuple([]) == ()",
      "assert convert_list_tuple(['a', 'b']) == ('a', 'b')"
    ]
  },
  {
    "num": "4.3",
    "name": "Обмен значений",
    "code": "def swap_values(a, b) -> tuple:\n    \"\"\"Поменять местами два значения\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию swap_values(a, b), которая возвращает кортеж (b, a).\nПример: swap_values(1, 2) → (2, 1)",
    "test_code": [
      "assert swap_values(1, 2) == (2, 1)",
      "assert swap_values('a', 'b') == ('b', 'a')",
      "assert swap_values([1], [2]) == ([2], [1])",
      "assert swap_values(None, True) == (True, None)"
    ]
  },
  {
    "num": "4.4",
    "name": "Поиск минимума и максимума",
    "code": "def min_max_tuple(t: tuple) -> tuple:\n    \"\"\"Найти минимальный и максимальный элемент\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию min_max_tuple(t), которая находит минимальный и максимальный элемент в кортеже и возвращает их в виде кортежа (min, max).\nПример: min_max_tuple((3, 1, 4, 2)) → (1, 4)",
    "test_code": [
      "assert min_max_tuple((3, 1, 4, 2)) == (1, 4)",
      "assert min_max_tuple((5,)) == (5, 5)",
      "assert min_max_tuple((0, 0, 0)) == (0, 0)",
      "assert min_max_tuple((-5, -1, -3)) == (-5, -1)"
    ]
  },
  {
    "num": "4.5",
    "name": "Объединение кортежей",
    "code": "def concatenate_tuples(t1: tuple, t2: tuple) -> tuple:\n    \"\"\"Объединить два кортежа в один\"\"\"\n    pass",
    "level": "junior",
    "task_text": "Напишите функцию concatenate_tuples(t1, t2), которая объединяет два кортежа в один.\nПример: concatenate_tuples((1, 2), (3, 4)) → (1, 2, 3, 4)",
    "test_code": [
      "assert concatenate_tuples((1, 2), (3, 4)) == (1, 2, 3, 4)",
      "assert concatenate_tuples((), (1, 2)) == (1, 2)",
      "assert concatenate_tuples(('a',), ('b', 'c')) == ('a', 'b', 'c')",
      "assert concatenate_tuples((), ()) == ()"
    ]
  }
]